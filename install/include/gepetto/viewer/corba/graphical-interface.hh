// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __graphical_interface_hh__
#define __graphical_interface_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_graphical_interface
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_graphical_interface
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_graphical_interface
#endif






#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE gepetto

_CORBA_MODULE_BEG

  class Error : public ::CORBA::UserException {
  public:
    
    ::CORBA::String_member msg;

  

    inline Error() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    Error(const Error&);
    Error(const char* i_msg);
    Error& operator=(const Error&);
    virtual ~Error();
    virtual void _raise() const;
    static Error* _downcast(::CORBA::Exception*);
    static const Error* _downcast(const ::CORBA::Exception*);
    static inline Error* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    void operator>>=(cdrStream&) const ;
    void operator<<=(cdrStream&) ;

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE corbaserver

  _CORBA_MODULE_BEG

    typedef ::CORBA::Float Transform[7];
    typedef ::CORBA::Float Transform_slice;

    _CORBA_MODULE_INLINE Transform_slice* Transform_alloc() {
      return new Transform_slice[7];
    }

    _CORBA_MODULE_INLINE Transform_slice* Transform_dup(const Transform_slice* _s) {
      if (!_s) return 0;
      Transform_slice* _data = Transform_alloc();
      if (_data) {
        for (_CORBA_ULong _0i0 = 0; _0i0 < 7; _0i0++){
          
          _data[_0i0] = _s[_0i0];

        }
    
      }
      return _data;
    }

    _CORBA_MODULE_INLINE void Transform_copy(Transform_slice* _to, const Transform_slice* _from){
      for (_CORBA_ULong _0i0 = 0; _0i0 < 7; _0i0++){
        
        _to[_0i0] = _from[_0i0];

      }
    
    }

    _CORBA_MODULE_INLINE void Transform_free(Transform_slice* _s) {
      delete [] _s;
    }

    class Transform_copyHelper {
    public:
      static inline Transform_slice* alloc() { return ::gepetto::corbaserver::Transform_alloc(); }
      static inline Transform_slice* dup(const Transform_slice* p) { return ::gepetto::corbaserver::Transform_dup(p); }
      static inline void free(Transform_slice* p) { ::gepetto::corbaserver::Transform_free(p); }
    };

    typedef _CORBA_Array_Fix_Var<Transform_copyHelper,Transform_slice> Transform_var;
    typedef _CORBA_Array_Fix_Forany<Transform_copyHelper,Transform_slice> Transform_forany;

    typedef Transform_slice* Transform_out;

    typedef ::CORBA::Float Vector2[2];
    typedef ::CORBA::Float Vector2_slice;

    _CORBA_MODULE_INLINE Vector2_slice* Vector2_alloc() {
      return new Vector2_slice[2];
    }

    _CORBA_MODULE_INLINE Vector2_slice* Vector2_dup(const Vector2_slice* _s) {
      if (!_s) return 0;
      Vector2_slice* _data = Vector2_alloc();
      if (_data) {
        for (_CORBA_ULong _0i0 = 0; _0i0 < 2; _0i0++){
          
          _data[_0i0] = _s[_0i0];

        }
    
      }
      return _data;
    }

    _CORBA_MODULE_INLINE void Vector2_copy(Vector2_slice* _to, const Vector2_slice* _from){
      for (_CORBA_ULong _0i0 = 0; _0i0 < 2; _0i0++){
        
        _to[_0i0] = _from[_0i0];

      }
    
    }

    _CORBA_MODULE_INLINE void Vector2_free(Vector2_slice* _s) {
      delete [] _s;
    }

    class Vector2_copyHelper {
    public:
      static inline Vector2_slice* alloc() { return ::gepetto::corbaserver::Vector2_alloc(); }
      static inline Vector2_slice* dup(const Vector2_slice* p) { return ::gepetto::corbaserver::Vector2_dup(p); }
      static inline void free(Vector2_slice* p) { ::gepetto::corbaserver::Vector2_free(p); }
    };

    typedef _CORBA_Array_Fix_Var<Vector2_copyHelper,Vector2_slice> Vector2_var;
    typedef _CORBA_Array_Fix_Forany<Vector2_copyHelper,Vector2_slice> Vector2_forany;

    typedef Vector2_slice* Vector2_out;

    typedef ::CORBA::Float Position[3];
    typedef ::CORBA::Float Position_slice;

    _CORBA_MODULE_INLINE Position_slice* Position_alloc() {
      return new Position_slice[3];
    }

    _CORBA_MODULE_INLINE Position_slice* Position_dup(const Position_slice* _s) {
      if (!_s) return 0;
      Position_slice* _data = Position_alloc();
      if (_data) {
        for (_CORBA_ULong _0i0 = 0; _0i0 < 3; _0i0++){
          
          _data[_0i0] = _s[_0i0];

        }
    
      }
      return _data;
    }

    _CORBA_MODULE_INLINE void Position_copy(Position_slice* _to, const Position_slice* _from){
      for (_CORBA_ULong _0i0 = 0; _0i0 < 3; _0i0++){
        
        _to[_0i0] = _from[_0i0];

      }
    
    }

    _CORBA_MODULE_INLINE void Position_free(Position_slice* _s) {
      delete [] _s;
    }

    class Position_copyHelper {
    public:
      static inline Position_slice* alloc() { return ::gepetto::corbaserver::Position_alloc(); }
      static inline Position_slice* dup(const Position_slice* p) { return ::gepetto::corbaserver::Position_dup(p); }
      static inline void free(Position_slice* p) { ::gepetto::corbaserver::Position_free(p); }
    };

    typedef _CORBA_Array_Fix_Var<Position_copyHelper,Position_slice> Position_var;
    typedef _CORBA_Array_Fix_Forany<Position_copyHelper,Position_slice> Position_forany;

    typedef Position_slice* Position_out;

    typedef ::CORBA::Float Color[4];
    typedef ::CORBA::Float Color_slice;

    _CORBA_MODULE_INLINE Color_slice* Color_alloc() {
      return new Color_slice[4];
    }

    _CORBA_MODULE_INLINE Color_slice* Color_dup(const Color_slice* _s) {
      if (!_s) return 0;
      Color_slice* _data = Color_alloc();
      if (_data) {
        for (_CORBA_ULong _0i0 = 0; _0i0 < 4; _0i0++){
          
          _data[_0i0] = _s[_0i0];

        }
    
      }
      return _data;
    }

    _CORBA_MODULE_INLINE void Color_copy(Color_slice* _to, const Color_slice* _from){
      for (_CORBA_ULong _0i0 = 0; _0i0 < 4; _0i0++){
        
        _to[_0i0] = _from[_0i0];

      }
    
    }

    _CORBA_MODULE_INLINE void Color_free(Color_slice* _s) {
      delete [] _s;
    }

    class Color_copyHelper {
    public:
      static inline Color_slice* alloc() { return ::gepetto::corbaserver::Color_alloc(); }
      static inline Color_slice* dup(const Color_slice* p) { return ::gepetto::corbaserver::Color_dup(p); }
      static inline void free(Color_slice* p) { ::gepetto::corbaserver::Color_free(p); }
    };

    typedef _CORBA_Array_Fix_Var<Color_copyHelper,Color_slice> Color_var;
    typedef _CORBA_Array_Fix_Forany<Color_copyHelper,Color_slice> Color_forany;

    typedef Color_slice* Color_out;

    typedef ::CORBA::ULong WindowID;
    typedef ::CORBA::ULong_out WindowID_out;

    class Names_t_var;

    class Names_t : public _CORBA_Unbounded_Sequence_String {
    public:
      typedef Names_t_var _var_type;
      inline Names_t() {}
      inline Names_t(const Names_t& _s)
        : _CORBA_Unbounded_Sequence_String(_s) {}

      inline Names_t(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_String(_max) {}
      inline Names_t(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}

    

      inline Names_t& operator = (const Names_t& _s) {
        _CORBA_Unbounded_Sequence_String::operator=(_s);
        return *this;
      }
    };

    class Names_t_out;

    class Names_t_var {
    public:
      inline Names_t_var() : _pd_seq(0) {}
      inline Names_t_var(Names_t* _s) : _pd_seq(_s) {}
      inline Names_t_var(const Names_t_var& _s) {
        if( _s._pd_seq )  _pd_seq = new Names_t(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~Names_t_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline Names_t_var& operator = (Names_t* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline Names_t_var& operator = (const Names_t_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new Names_t;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline Names_t* operator -> () { return _pd_seq; }
      inline const Names_t* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator Names_t& () const { return *_pd_seq; }
#else
      inline operator const Names_t& () const { return *_pd_seq; }
      inline operator Names_t& () { return *_pd_seq; }
#endif
        
      inline const Names_t& in() const { return *_pd_seq; }
      inline Names_t&       inout()    { return *_pd_seq; }
      inline Names_t*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline Names_t* _retn() { Names_t* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class Names_t_out;
      
    private:
      Names_t* _pd_seq;
    };

    class Names_t_out {
    public:
      inline Names_t_out(Names_t*& _s) : _data(_s) { _data = 0; }
      inline Names_t_out(Names_t_var& _s)
        : _data(_s._pd_seq) { _s = (Names_t*) 0; }
      inline Names_t_out(const Names_t_out& _s) : _data(_s._data) {}
      inline Names_t_out& operator = (const Names_t_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline Names_t_out& operator = (Names_t* _s) {
        _data = _s;
        return *this;
      }
      inline operator Names_t*&()  { return _data; }
      inline Names_t*& ptr()       { return _data; }
      inline Names_t* operator->() { return _data; }

      inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      Names_t*& _data;

    private:
      Names_t_out();
      Names_t_out& operator=(const Names_t_var&);
    };

    class floatSeq_var;

    class floatSeq : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Float, 4, 4 >  {
    public:
      typedef floatSeq_var _var_type;
      inline floatSeq() {}
      inline floatSeq(const floatSeq& _s)
        : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Float, 4, 4 > (_s) {}

      inline floatSeq(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Float, 4, 4 > (_max) {}
      inline floatSeq(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Float* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Float, 4, 4 > (_max, _len, _val, _rel) {}

    

      inline floatSeq& operator = (const floatSeq& _s) {
        _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Float, 4, 4 > ::operator=(_s);
        return *this;
      }
    };

    class floatSeq_out;

    class floatSeq_var {
    public:
      inline floatSeq_var() : _pd_seq(0) {}
      inline floatSeq_var(floatSeq* _s) : _pd_seq(_s) {}
      inline floatSeq_var(const floatSeq_var& _s) {
        if( _s._pd_seq )  _pd_seq = new floatSeq(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~floatSeq_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline floatSeq_var& operator = (floatSeq* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline floatSeq_var& operator = (const floatSeq_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new floatSeq;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline ::CORBA::Float& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline floatSeq* operator -> () { return _pd_seq; }
      inline const floatSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator floatSeq& () const { return *_pd_seq; }
#else
      inline operator const floatSeq& () const { return *_pd_seq; }
      inline operator floatSeq& () { return *_pd_seq; }
#endif
        
      inline const floatSeq& in() const { return *_pd_seq; }
      inline floatSeq&       inout()    { return *_pd_seq; }
      inline floatSeq*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline floatSeq* _retn() { floatSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class floatSeq_out;
      
    private:
      floatSeq* _pd_seq;
    };

    class floatSeq_out {
    public:
      inline floatSeq_out(floatSeq*& _s) : _data(_s) { _data = 0; }
      inline floatSeq_out(floatSeq_var& _s)
        : _data(_s._pd_seq) { _s = (floatSeq*) 0; }
      inline floatSeq_out(const floatSeq_out& _s) : _data(_s._data) {}
      inline floatSeq_out& operator = (const floatSeq_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline floatSeq_out& operator = (floatSeq* _s) {
        _data = _s;
        return *this;
      }
      inline operator floatSeq*&()  { return _data; }
      inline floatSeq*& ptr()       { return _data; }
      inline floatSeq* operator->() { return _data; }

      inline ::CORBA::Float& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      floatSeq*& _data;

    private:
      floatSeq_out();
      floatSeq_out& operator=(const floatSeq_var&);
    };

    class PositionSeq_var;

    class PositionSeq : public _CORBA_Unbounded_Sequence_Array_w_FixSizeElement< Position, Position_slice, ::CORBA::Float, 3, 4, 4 >  {
    public:
      typedef PositionSeq_var _var_type;
      inline PositionSeq() {}
      inline PositionSeq(const PositionSeq& _s)
        : _CORBA_Unbounded_Sequence_Array_w_FixSizeElement< Position, Position_slice, ::CORBA::Float, 3, 4, 4 > (_s) {}

      inline PositionSeq(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_Array_w_FixSizeElement< Position, Position_slice, ::CORBA::Float, 3, 4, 4 > (_max) {}
      inline PositionSeq(_CORBA_ULong _max, _CORBA_ULong _len, Position* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_Array_w_FixSizeElement< Position, Position_slice, ::CORBA::Float, 3, 4, 4 > (_max, _len, _val, _rel) {}

    

      inline PositionSeq& operator = (const PositionSeq& _s) {
        _CORBA_Unbounded_Sequence_Array_w_FixSizeElement< Position, Position_slice, ::CORBA::Float, 3, 4, 4 > ::operator=(_s);
        return *this;
      }
    };

    class PositionSeq_out;

    class PositionSeq_var {
    public:
      inline PositionSeq_var() : _pd_seq(0) {}
      inline PositionSeq_var(PositionSeq* _s) : _pd_seq(_s) {}
      inline PositionSeq_var(const PositionSeq_var& _s) {
        if( _s._pd_seq )  _pd_seq = new PositionSeq(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~PositionSeq_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline PositionSeq_var& operator = (PositionSeq* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline PositionSeq_var& operator = (const PositionSeq_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new PositionSeq;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline Position_slice* operator [] (_CORBA_ULong _s) {
        return (Position_slice*) ((_pd_seq->NP_data())[_s]);
      }

    

      inline PositionSeq* operator -> () { return _pd_seq; }
      inline const PositionSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator PositionSeq& () const { return *_pd_seq; }
#else
      inline operator const PositionSeq& () const { return *_pd_seq; }
      inline operator PositionSeq& () { return *_pd_seq; }
#endif
        
      inline const PositionSeq& in() const { return *_pd_seq; }
      inline PositionSeq&       inout()    { return *_pd_seq; }
      inline PositionSeq*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline PositionSeq* _retn() { PositionSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class PositionSeq_out;
      
    private:
      PositionSeq* _pd_seq;
    };

    class PositionSeq_out {
    public:
      inline PositionSeq_out(PositionSeq*& _s) : _data(_s) { _data = 0; }
      inline PositionSeq_out(PositionSeq_var& _s)
        : _data(_s._pd_seq) { _s = (PositionSeq*) 0; }
      inline PositionSeq_out(const PositionSeq_out& _s) : _data(_s._data) {}
      inline PositionSeq_out& operator = (const PositionSeq_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline PositionSeq_out& operator = (PositionSeq* _s) {
        _data = _s;
        return *this;
      }
      inline operator PositionSeq*&()  { return _data; }
      inline PositionSeq*& ptr()       { return _data; }
      inline PositionSeq* operator->() { return _data; }

      inline Position_slice* operator [] (_CORBA_ULong _i) {
        return (Position_slice*) ((_data->NP_data())[_i]);
      }

    

      PositionSeq*& _data;

    private:
      PositionSeq_out();
      PositionSeq_out& operator=(const PositionSeq_var&);
    };

    class TransformSeq_var;

    class TransformSeq : public _CORBA_Unbounded_Sequence_Array_w_FixSizeElement< Transform, Transform_slice, ::CORBA::Float, 7, 4, 4 >  {
    public:
      typedef TransformSeq_var _var_type;
      inline TransformSeq() {}
      inline TransformSeq(const TransformSeq& _s)
        : _CORBA_Unbounded_Sequence_Array_w_FixSizeElement< Transform, Transform_slice, ::CORBA::Float, 7, 4, 4 > (_s) {}

      inline TransformSeq(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_Array_w_FixSizeElement< Transform, Transform_slice, ::CORBA::Float, 7, 4, 4 > (_max) {}
      inline TransformSeq(_CORBA_ULong _max, _CORBA_ULong _len, Transform* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_Array_w_FixSizeElement< Transform, Transform_slice, ::CORBA::Float, 7, 4, 4 > (_max, _len, _val, _rel) {}

    

      inline TransformSeq& operator = (const TransformSeq& _s) {
        _CORBA_Unbounded_Sequence_Array_w_FixSizeElement< Transform, Transform_slice, ::CORBA::Float, 7, 4, 4 > ::operator=(_s);
        return *this;
      }
    };

    class TransformSeq_out;

    class TransformSeq_var {
    public:
      inline TransformSeq_var() : _pd_seq(0) {}
      inline TransformSeq_var(TransformSeq* _s) : _pd_seq(_s) {}
      inline TransformSeq_var(const TransformSeq_var& _s) {
        if( _s._pd_seq )  _pd_seq = new TransformSeq(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~TransformSeq_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline TransformSeq_var& operator = (TransformSeq* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline TransformSeq_var& operator = (const TransformSeq_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new TransformSeq;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline Transform_slice* operator [] (_CORBA_ULong _s) {
        return (Transform_slice*) ((_pd_seq->NP_data())[_s]);
      }

    

      inline TransformSeq* operator -> () { return _pd_seq; }
      inline const TransformSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator TransformSeq& () const { return *_pd_seq; }
#else
      inline operator const TransformSeq& () const { return *_pd_seq; }
      inline operator TransformSeq& () { return *_pd_seq; }
#endif
        
      inline const TransformSeq& in() const { return *_pd_seq; }
      inline TransformSeq&       inout()    { return *_pd_seq; }
      inline TransformSeq*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline TransformSeq* _retn() { TransformSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class TransformSeq_out;
      
    private:
      TransformSeq* _pd_seq;
    };

    class TransformSeq_out {
    public:
      inline TransformSeq_out(TransformSeq*& _s) : _data(_s) { _data = 0; }
      inline TransformSeq_out(TransformSeq_var& _s)
        : _data(_s._pd_seq) { _s = (TransformSeq*) 0; }
      inline TransformSeq_out(const TransformSeq_out& _s) : _data(_s._data) {}
      inline TransformSeq_out& operator = (const TransformSeq_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline TransformSeq_out& operator = (TransformSeq* _s) {
        _data = _s;
        return *this;
      }
      inline operator TransformSeq*&()  { return _data; }
      inline TransformSeq*& ptr()       { return _data; }
      inline TransformSeq* operator->() { return _data; }

      inline Transform_slice* operator [] (_CORBA_ULong _i) {
        return (Transform_slice*) ((_data->NP_data())[_i]);
      }

    

      TransformSeq*& _data;

    private:
      TransformSeq_out();
      TransformSeq_out& operator=(const TransformSeq_var&);
    };

#ifndef __gepetto_mcorbaserver_mNodeCallback__
#define __gepetto_mcorbaserver_mNodeCallback__

    class NodeCallback;
    class _objref_NodeCallback;
    class _impl_NodeCallback;
    
    typedef _objref_NodeCallback* NodeCallback_ptr;
    typedef NodeCallback_ptr NodeCallbackRef;

    class NodeCallback_Helper {
    public:
      typedef NodeCallback_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_NodeCallback, NodeCallback_Helper> NodeCallback_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_NodeCallback,NodeCallback_Helper > NodeCallback_out;

#endif

    // interface NodeCallback
    class NodeCallback {
    public:
      // Declarations for this interface type.
      typedef NodeCallback_ptr _ptr_type;
      typedef NodeCallback_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_NodeCallback :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      void selected(const char* name, const ::gepetto::corbaserver::Position positionInWorldFrame, const ::gepetto::corbaserver::Position normalInLocalFrame);

      inline _objref_NodeCallback()  { _PR_setobj(0); }  // nil
      _objref_NodeCallback(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_NodeCallback();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_NodeCallback(const _objref_NodeCallback&);
      _objref_NodeCallback& operator = (const _objref_NodeCallback&);
      // not implemented

      friend class NodeCallback;
    };

    class _pof_NodeCallback : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_NodeCallback() : _OMNI_NS(proxyObjectFactory)(NodeCallback::_PD_repoId) {}
      virtual ~_pof_NodeCallback();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_NodeCallback :
      public virtual omniServant
    {
    public:
      virtual ~_impl_NodeCallback();

      virtual void selected(const char* name, const ::gepetto::corbaserver::Position positionInWorldFrame, const ::gepetto::corbaserver::Position normalInLocalFrame) = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


#ifndef __gepetto_mcorbaserver_mGraphicalInterface__
#define __gepetto_mcorbaserver_mGraphicalInterface__

    class GraphicalInterface;
    class _objref_GraphicalInterface;
    class _impl_GraphicalInterface;
    
    typedef _objref_GraphicalInterface* GraphicalInterface_ptr;
    typedef GraphicalInterface_ptr GraphicalInterfaceRef;

    class GraphicalInterface_Helper {
    public:
      typedef GraphicalInterface_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_GraphicalInterface, GraphicalInterface_Helper> GraphicalInterface_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_GraphicalInterface,GraphicalInterface_Helper > GraphicalInterface_out;

#endif

    // interface GraphicalInterface
    class GraphicalInterface {
    public:
      // Declarations for this interface type.
      typedef GraphicalInterface_ptr _ptr_type;
      typedef GraphicalInterface_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_GraphicalInterface :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      ::CORBA::ULong createWindow(const char* name);
      ::CORBA::ULong getWindowID(const char* name);
      ::CORBA::Boolean setBackgroundColor1(::CORBA::ULong windowId, const ::gepetto::corbaserver::Color RGBAcolor);
      ::CORBA::Boolean setBackgroundColor2(::CORBA::ULong windowId, const ::gepetto::corbaserver::Color RGBAcolor);
      void createScene(const char* sceneName);
      void createSceneWithFloor(const char* sceneName);
      ::CORBA::Boolean addSceneToWindow(const char* sceneName, ::CORBA::ULong windowId);
      ::CORBA::Boolean addFloor(const char* floorName);
      ::CORBA::Boolean addBox(const char* boxName, ::CORBA::Float boxSize1, ::CORBA::Float boxSize2, ::CORBA::Float boxSize3, const ::gepetto::corbaserver::Color RGBAcolor);
      ::CORBA::Boolean addCapsule(const char* capsuleName, ::CORBA::Float radius, ::CORBA::Float height, const ::gepetto::corbaserver::Color RGBAcolorid);
      ::CORBA::Boolean addArrow(const char* arrowName, ::CORBA::Float radius, ::CORBA::Float length, const ::gepetto::corbaserver::Color RGBAcolorid);
      ::CORBA::Boolean addRod(const char* rodName, const ::gepetto::corbaserver::Color RGBAcolorid, ::CORBA::Float radius, ::CORBA::Float totalLength, ::CORBA::Short maxCapsule);
      ::CORBA::Boolean resizeCapsule(const char* capsuleName, ::CORBA::Float height);
      ::CORBA::Boolean resizeArrow(const char* capsuleName, ::CORBA::Float radius, ::CORBA::Float length);
      ::CORBA::Boolean addMesh(const char* meshName, const char* meshPath);
      ::CORBA::Boolean addCone(const char* coneName, ::CORBA::Float radius, ::CORBA::Float height, const ::gepetto::corbaserver::Color RGBAcolor);
      ::CORBA::Boolean addCylinder(const char* cylinderName, ::CORBA::Float radius, ::CORBA::Float height, const ::gepetto::corbaserver::Color RGBAcolor);
      ::CORBA::Boolean addSphere(const char* sphereName, ::CORBA::Float radius, const ::gepetto::corbaserver::Color RGBAcolor);
      ::CORBA::Boolean addLight(const char* lightName, ::gepetto::corbaserver::WindowID wid, ::CORBA::Float radius, const ::gepetto::corbaserver::Color RGBAcolor);
      ::CORBA::Boolean addLine(const char* lineName, const ::gepetto::corbaserver::Position pos1, const ::gepetto::corbaserver::Position pos2, const ::gepetto::corbaserver::Color RGBAcolor);
      ::CORBA::Boolean setLineStartPoint(const char* lineName, const ::gepetto::corbaserver::Position pos1);
      ::CORBA::Boolean setLineEndPoint(const char* lineName, const ::gepetto::corbaserver::Position pos2);
      ::CORBA::Boolean setLineExtremalPoints(const char* lineName, const ::gepetto::corbaserver::Position pos1, const ::gepetto::corbaserver::Position pos2);
      ::CORBA::Boolean addCurve(const char* curveName, const ::gepetto::corbaserver::PositionSeq& pos, const ::gepetto::corbaserver::Color RGBAcolor);
      ::CORBA::Boolean setCurvePoints(const char* curveName, const ::gepetto::corbaserver::PositionSeq& pos);
      ::CORBA::Boolean setCurveMode(const char* curveName, const char* mode);
      ::CORBA::Boolean setCurvePointsSubset(const char* curveName, ::CORBA::Long first, ::CORBA::Long count);
      ::CORBA::Boolean setCurveLineWidth(const char* curveName, ::CORBA::Float width);
      ::CORBA::Boolean addSquareFace(const char* faceName, const ::gepetto::corbaserver::Position pos1, const ::gepetto::corbaserver::Position pos2, const ::gepetto::corbaserver::Position pos3, const ::gepetto::corbaserver::Position pos4, const ::gepetto::corbaserver::Color RGBAcolor);
      ::CORBA::Boolean setTexture(const char* nodeName, const char* filename);
      ::CORBA::Boolean addTriangleFace(const char* faceName, const ::gepetto::corbaserver::Position pos1, const ::gepetto::corbaserver::Position pos2, const ::gepetto::corbaserver::Position pos3, const ::gepetto::corbaserver::Color RGBAcolor);
      ::CORBA::Boolean addXYZaxis(const char* nodeName, const ::gepetto::corbaserver::Color RGBAcolor, ::CORBA::Float radius, ::CORBA::Float sizeAxis);
      ::CORBA::Boolean createRoadmap(const char* nameCorba, const ::gepetto::corbaserver::Color RGBAcolorNode, ::CORBA::Float radius, ::CORBA::Float sizeAxis, const ::gepetto::corbaserver::Color RGBAcolorEdge);
      ::CORBA::Boolean addEdgeToRoadmap(const char* nameRoadmap, const ::gepetto::corbaserver::Position posFrom, const ::gepetto::corbaserver::Position posTo);
      ::CORBA::Boolean addNodeToRoadmap(const char* nameRoadmap, const ::gepetto::corbaserver::Transform configuration);
      ::CORBA::Boolean addURDF(const char* robotName, const char* urdfFilePath, const char* meshDataRootDir);
      ::CORBA::Boolean addUrdfCollision(const char* robotName, const char* urdfFilePath, const char* meshDataRootDir);
      void addUrdfObjects(const char* nodeName, const char* urdfFilePath, const char* meshDataRootDir, ::CORBA::Boolean visual);
      ::CORBA::Boolean createGroup(const char* groupName);
      ::CORBA::Boolean nodeExists(const char* nodeName);
      void deleteNode(const char* nodeName, ::CORBA::Boolean all);
      Names_t* getNodeList();
      Names_t* getGroupNodeList(const char* group);
      Names_t* getSceneList();
      Names_t* getWindowList();
      ::CORBA::Boolean addToGroup(const char* nodeName, const char* groupName);
      ::CORBA::Boolean removeFromGroup(const char* nodeName, const char* groupName);
      ::CORBA::Boolean applyConfiguration(const char* nodeName, const ::gepetto::corbaserver::Transform configuration);
      ::CORBA::Boolean applyConfigurations(const ::gepetto::corbaserver::Names_t& nodeName, const ::gepetto::corbaserver::TransformSeq& configuration);
      void refresh();
      void setRefreshIsSynchronous(::CORBA::Boolean synchonous);
      Transform_slice* getNodeGlobalTransform(const char* nodeName);
      ::CORBA::Boolean addLandmark(const char* nodeName, ::CORBA::Float size);
      ::CORBA::Boolean deleteLandmark(const char* nodeName);
      Transform_slice* getStaticTransform(const char* nodeName);
      ::CORBA::Boolean setStaticTransform(const char* nodeName, const ::gepetto::corbaserver::Transform configuration);
      ::CORBA::Boolean setVisibility(const char* nodeName, const char* visibilityMode);
      ::CORBA::Boolean setScale(const char* nodeName, const ::gepetto::corbaserver::Position scale);
      ::CORBA::Boolean setColor(const char* nodeName, const ::gepetto::corbaserver::Color scale);
      ::CORBA::Boolean setWireFrameMode(const char* nodeName, const char* wireFrameMode);
      ::CORBA::Boolean setLightingMode(const char* nodeName, const char* lightingMode);
      ::CORBA::Boolean setHighlight(const char* nodeName, ::CORBA::Long state);
      Names_t* getPropertyNames(const char* nodeName);
      Names_t* getPropertyTypes(const char* nodeName);
      void setStringProperty(const char* nodeName, const char* propName, const char* value);
      char* getStringProperty(const char* nodeName, const char* propName);
      void setColorProperty(const char* nodeName, const char* propName, const ::gepetto::corbaserver::Color value);
      Color_slice* getColorProperty(const char* nodeName, const char* propName);
      void setVector3Property(const char* nodeName, const char* propName, const ::gepetto::corbaserver::Position value);
      Position_slice* getVector3Property(const char* nodeName, const char* propName);
      void setVector2Property(const char* nodeName, const char* propName, const ::gepetto::corbaserver::Vector2 value);
      Position_slice* getVector2Property(const char* nodeName, const char* propName);
      void setFloatProperty(const char* nodeName, const char* propName, ::CORBA::Float value);
      ::CORBA::Float getFloatProperty(const char* nodeName, const char* propName);
      void setBoolProperty(const char* nodeName, const char* propName, ::CORBA::Boolean value);
      ::CORBA::Boolean getBoolProperty(const char* nodeName, const char* propName);
      void setIntProperty(const char* nodeName, const char* propName, ::CORBA::Long value);
      ::CORBA::Long getIntProperty(const char* nodeName, const char* propName);
      void captureFrame(::gepetto::corbaserver::WindowID wid, const char* imageFilename);
      ::CORBA::Boolean startCapture(::CORBA::ULong windowId, const char* filename, const char* extension);
      ::CORBA::Boolean stopCapture(::CORBA::ULong windowId);
      ::CORBA::Boolean setCaptureTransform(const char* filename, const ::gepetto::corbaserver::Names_t& nodeNames);
      void captureTransformOnRefresh(::CORBA::Boolean autoCapture);
      void captureTransform();
      ::CORBA::Boolean writeBlenderScript(const char* filename, const ::gepetto::corbaserver::Names_t& nodeNames);
      ::CORBA::Boolean writeNodeFile(const char* nodeName, const char* filename);
      ::CORBA::Boolean writeWindowFile(::CORBA::ULong windowId, const char* filename);
      ::CORBA::Boolean attachCameraToNode(const char* nodeName, ::CORBA::ULong windowId);
      ::CORBA::Boolean detachCamera(::CORBA::ULong windowId);
      Transform_slice* getCameraTransform(::CORBA::ULong windowId);
      ::CORBA::Boolean setCameraTransform(::CORBA::ULong windowId, const ::gepetto::corbaserver::Transform configuration);
      ::CORBA::Boolean registerNodeCallback(::gepetto::corbaserver::NodeCallback_ptr cb);

      inline _objref_GraphicalInterface()  { _PR_setobj(0); }  // nil
      _objref_GraphicalInterface(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_GraphicalInterface();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_GraphicalInterface(const _objref_GraphicalInterface&);
      _objref_GraphicalInterface& operator = (const _objref_GraphicalInterface&);
      // not implemented

      friend class GraphicalInterface;
    };

    class _pof_GraphicalInterface : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_GraphicalInterface() : _OMNI_NS(proxyObjectFactory)(GraphicalInterface::_PD_repoId) {}
      virtual ~_pof_GraphicalInterface();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_GraphicalInterface :
      public virtual omniServant
    {
    public:
      virtual ~_impl_GraphicalInterface();

      virtual ::CORBA::ULong createWindow(const char* name) = 0;
      virtual ::CORBA::ULong getWindowID(const char* name) = 0;
      virtual ::CORBA::Boolean setBackgroundColor1(::CORBA::ULong windowId, const ::gepetto::corbaserver::Color RGBAcolor) = 0;
      virtual ::CORBA::Boolean setBackgroundColor2(::CORBA::ULong windowId, const ::gepetto::corbaserver::Color RGBAcolor) = 0;
      virtual void createScene(const char* sceneName) = 0;
      virtual void createSceneWithFloor(const char* sceneName) = 0;
      virtual ::CORBA::Boolean addSceneToWindow(const char* sceneName, ::CORBA::ULong windowId) = 0;
      virtual ::CORBA::Boolean addFloor(const char* floorName) = 0;
      virtual ::CORBA::Boolean addBox(const char* boxName, ::CORBA::Float boxSize1, ::CORBA::Float boxSize2, ::CORBA::Float boxSize3, const ::gepetto::corbaserver::Color RGBAcolor) = 0;
      virtual ::CORBA::Boolean addCapsule(const char* capsuleName, ::CORBA::Float radius, ::CORBA::Float height, const ::gepetto::corbaserver::Color RGBAcolorid) = 0;
      virtual ::CORBA::Boolean addArrow(const char* arrowName, ::CORBA::Float radius, ::CORBA::Float length, const ::gepetto::corbaserver::Color RGBAcolorid) = 0;
      virtual ::CORBA::Boolean addRod(const char* rodName, const ::gepetto::corbaserver::Color RGBAcolorid, ::CORBA::Float radius, ::CORBA::Float totalLength, ::CORBA::Short maxCapsule) = 0;
      virtual ::CORBA::Boolean resizeCapsule(const char* capsuleName, ::CORBA::Float height) = 0;
      virtual ::CORBA::Boolean resizeArrow(const char* capsuleName, ::CORBA::Float radius, ::CORBA::Float length) = 0;
      virtual ::CORBA::Boolean addMesh(const char* meshName, const char* meshPath) = 0;
      virtual ::CORBA::Boolean addCone(const char* coneName, ::CORBA::Float radius, ::CORBA::Float height, const ::gepetto::corbaserver::Color RGBAcolor) = 0;
      virtual ::CORBA::Boolean addCylinder(const char* cylinderName, ::CORBA::Float radius, ::CORBA::Float height, const ::gepetto::corbaserver::Color RGBAcolor) = 0;
      virtual ::CORBA::Boolean addSphere(const char* sphereName, ::CORBA::Float radius, const ::gepetto::corbaserver::Color RGBAcolor) = 0;
      virtual ::CORBA::Boolean addLight(const char* lightName, ::gepetto::corbaserver::WindowID wid, ::CORBA::Float radius, const ::gepetto::corbaserver::Color RGBAcolor) = 0;
      virtual ::CORBA::Boolean addLine(const char* lineName, const ::gepetto::corbaserver::Position pos1, const ::gepetto::corbaserver::Position pos2, const ::gepetto::corbaserver::Color RGBAcolor) = 0;
      virtual ::CORBA::Boolean setLineStartPoint(const char* lineName, const ::gepetto::corbaserver::Position pos1) = 0;
      virtual ::CORBA::Boolean setLineEndPoint(const char* lineName, const ::gepetto::corbaserver::Position pos2) = 0;
      virtual ::CORBA::Boolean setLineExtremalPoints(const char* lineName, const ::gepetto::corbaserver::Position pos1, const ::gepetto::corbaserver::Position pos2) = 0;
      virtual ::CORBA::Boolean addCurve(const char* curveName, const ::gepetto::corbaserver::PositionSeq& pos, const ::gepetto::corbaserver::Color RGBAcolor) = 0;
      virtual ::CORBA::Boolean setCurvePoints(const char* curveName, const ::gepetto::corbaserver::PositionSeq& pos) = 0;
      virtual ::CORBA::Boolean setCurveMode(const char* curveName, const char* mode) = 0;
      virtual ::CORBA::Boolean setCurvePointsSubset(const char* curveName, ::CORBA::Long first, ::CORBA::Long count) = 0;
      virtual ::CORBA::Boolean setCurveLineWidth(const char* curveName, ::CORBA::Float width) = 0;
      virtual ::CORBA::Boolean addSquareFace(const char* faceName, const ::gepetto::corbaserver::Position pos1, const ::gepetto::corbaserver::Position pos2, const ::gepetto::corbaserver::Position pos3, const ::gepetto::corbaserver::Position pos4, const ::gepetto::corbaserver::Color RGBAcolor) = 0;
      virtual ::CORBA::Boolean setTexture(const char* nodeName, const char* filename) = 0;
      virtual ::CORBA::Boolean addTriangleFace(const char* faceName, const ::gepetto::corbaserver::Position pos1, const ::gepetto::corbaserver::Position pos2, const ::gepetto::corbaserver::Position pos3, const ::gepetto::corbaserver::Color RGBAcolor) = 0;
      virtual ::CORBA::Boolean addXYZaxis(const char* nodeName, const ::gepetto::corbaserver::Color RGBAcolor, ::CORBA::Float radius, ::CORBA::Float sizeAxis) = 0;
      virtual ::CORBA::Boolean createRoadmap(const char* nameCorba, const ::gepetto::corbaserver::Color RGBAcolorNode, ::CORBA::Float radius, ::CORBA::Float sizeAxis, const ::gepetto::corbaserver::Color RGBAcolorEdge) = 0;
      virtual ::CORBA::Boolean addEdgeToRoadmap(const char* nameRoadmap, const ::gepetto::corbaserver::Position posFrom, const ::gepetto::corbaserver::Position posTo) = 0;
      virtual ::CORBA::Boolean addNodeToRoadmap(const char* nameRoadmap, const ::gepetto::corbaserver::Transform configuration) = 0;
      virtual ::CORBA::Boolean addURDF(const char* robotName, const char* urdfFilePath, const char* meshDataRootDir) = 0;
      virtual ::CORBA::Boolean addUrdfCollision(const char* robotName, const char* urdfFilePath, const char* meshDataRootDir) = 0;
      virtual void addUrdfObjects(const char* nodeName, const char* urdfFilePath, const char* meshDataRootDir, ::CORBA::Boolean visual) = 0;
      virtual ::CORBA::Boolean createGroup(const char* groupName) = 0;
      virtual ::CORBA::Boolean nodeExists(const char* nodeName) = 0;
      virtual void deleteNode(const char* nodeName, ::CORBA::Boolean all) = 0;
      virtual Names_t* getNodeList() = 0;
      virtual Names_t* getGroupNodeList(const char* group) = 0;
      virtual Names_t* getSceneList() = 0;
      virtual Names_t* getWindowList() = 0;
      virtual ::CORBA::Boolean addToGroup(const char* nodeName, const char* groupName) = 0;
      virtual ::CORBA::Boolean removeFromGroup(const char* nodeName, const char* groupName) = 0;
      virtual ::CORBA::Boolean applyConfiguration(const char* nodeName, const ::gepetto::corbaserver::Transform configuration) = 0;
      virtual ::CORBA::Boolean applyConfigurations(const ::gepetto::corbaserver::Names_t& nodeName, const ::gepetto::corbaserver::TransformSeq& configuration) = 0;
      virtual void refresh() = 0;
      virtual void setRefreshIsSynchronous(::CORBA::Boolean synchonous) = 0;
      virtual Transform_slice* getNodeGlobalTransform(const char* nodeName) = 0;
      virtual ::CORBA::Boolean addLandmark(const char* nodeName, ::CORBA::Float size) = 0;
      virtual ::CORBA::Boolean deleteLandmark(const char* nodeName) = 0;
      virtual Transform_slice* getStaticTransform(const char* nodeName) = 0;
      virtual ::CORBA::Boolean setStaticTransform(const char* nodeName, const ::gepetto::corbaserver::Transform configuration) = 0;
      virtual ::CORBA::Boolean setVisibility(const char* nodeName, const char* visibilityMode) = 0;
      virtual ::CORBA::Boolean setScale(const char* nodeName, const ::gepetto::corbaserver::Position scale) = 0;
      virtual ::CORBA::Boolean setColor(const char* nodeName, const ::gepetto::corbaserver::Color scale) = 0;
      virtual ::CORBA::Boolean setWireFrameMode(const char* nodeName, const char* wireFrameMode) = 0;
      virtual ::CORBA::Boolean setLightingMode(const char* nodeName, const char* lightingMode) = 0;
      virtual ::CORBA::Boolean setHighlight(const char* nodeName, ::CORBA::Long state) = 0;
      virtual Names_t* getPropertyNames(const char* nodeName) = 0;
      virtual Names_t* getPropertyTypes(const char* nodeName) = 0;
      virtual void setStringProperty(const char* nodeName, const char* propName, const char* value) = 0;
      virtual char* getStringProperty(const char* nodeName, const char* propName) = 0;
      virtual void setColorProperty(const char* nodeName, const char* propName, const ::gepetto::corbaserver::Color value) = 0;
      virtual Color_slice* getColorProperty(const char* nodeName, const char* propName) = 0;
      virtual void setVector3Property(const char* nodeName, const char* propName, const ::gepetto::corbaserver::Position value) = 0;
      virtual Position_slice* getVector3Property(const char* nodeName, const char* propName) = 0;
      virtual void setVector2Property(const char* nodeName, const char* propName, const ::gepetto::corbaserver::Vector2 value) = 0;
      virtual Position_slice* getVector2Property(const char* nodeName, const char* propName) = 0;
      virtual void setFloatProperty(const char* nodeName, const char* propName, ::CORBA::Float value) = 0;
      virtual ::CORBA::Float getFloatProperty(const char* nodeName, const char* propName) = 0;
      virtual void setBoolProperty(const char* nodeName, const char* propName, ::CORBA::Boolean value) = 0;
      virtual ::CORBA::Boolean getBoolProperty(const char* nodeName, const char* propName) = 0;
      virtual void setIntProperty(const char* nodeName, const char* propName, ::CORBA::Long value) = 0;
      virtual ::CORBA::Long getIntProperty(const char* nodeName, const char* propName) = 0;
      virtual void captureFrame(::gepetto::corbaserver::WindowID wid, const char* imageFilename) = 0;
      virtual ::CORBA::Boolean startCapture(::CORBA::ULong windowId, const char* filename, const char* extension) = 0;
      virtual ::CORBA::Boolean stopCapture(::CORBA::ULong windowId) = 0;
      virtual ::CORBA::Boolean setCaptureTransform(const char* filename, const ::gepetto::corbaserver::Names_t& nodeNames) = 0;
      virtual void captureTransformOnRefresh(::CORBA::Boolean autoCapture) = 0;
      virtual void captureTransform() = 0;
      virtual ::CORBA::Boolean writeBlenderScript(const char* filename, const ::gepetto::corbaserver::Names_t& nodeNames) = 0;
      virtual ::CORBA::Boolean writeNodeFile(const char* nodeName, const char* filename) = 0;
      virtual ::CORBA::Boolean writeWindowFile(::CORBA::ULong windowId, const char* filename) = 0;
      virtual ::CORBA::Boolean attachCameraToNode(const char* nodeName, ::CORBA::ULong windowId) = 0;
      virtual ::CORBA::Boolean detachCamera(::CORBA::ULong windowId) = 0;
      virtual Transform_slice* getCameraTransform(::CORBA::ULong windowId) = 0;
      virtual ::CORBA::Boolean setCameraTransform(::CORBA::ULong windowId, const ::gepetto::corbaserver::Transform configuration) = 0;
      virtual ::CORBA::Boolean registerNodeCallback(::gepetto::corbaserver::NodeCallback_ptr cb) = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


  _CORBA_MODULE_END

_CORBA_MODULE_END



_CORBA_MODULE POA_gepetto
_CORBA_MODULE_BEG

  _CORBA_MODULE corbaserver
  _CORBA_MODULE_BEG

    class NodeCallback :
      public virtual gepetto::corbaserver::_impl_NodeCallback,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~NodeCallback();

      inline ::gepetto::corbaserver::NodeCallback_ptr _this() {
        return (::gepetto::corbaserver::NodeCallback_ptr) _do_this(::gepetto::corbaserver::NodeCallback::_PD_repoId);
      }
    };

    class GraphicalInterface :
      public virtual gepetto::corbaserver::_impl_GraphicalInterface,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~GraphicalInterface();

      inline ::gepetto::corbaserver::GraphicalInterface_ptr _this() {
        return (::gepetto::corbaserver::GraphicalInterface_ptr) _do_this(::gepetto::corbaserver::GraphicalInterface::_PD_repoId);
      }
    };

  _CORBA_MODULE_END

_CORBA_MODULE_END



_CORBA_MODULE OBV_gepetto
_CORBA_MODULE_BEG

  _CORBA_MODULE corbaserver
  _CORBA_MODULE_BEG

  _CORBA_MODULE_END

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr



inline void
gepetto::corbaserver::NodeCallback::_marshalObjRef(::gepetto::corbaserver::NodeCallback_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
gepetto::corbaserver::GraphicalInterface::_marshalObjRef(::gepetto::corbaserver::GraphicalInterface_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}




#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_graphical_interface
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_graphical_interface
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_graphical_interface
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_graphical_interface
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_graphical_interface
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_graphical_interface
#endif

#endif  // __graphical_interface_hh__

