// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef hpp_manipulation_idl____graph_hh__
#define hpp_manipulation_idl____graph_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED___graph
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED___graph
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED___graph
#endif



#ifndef hpp_manipulation_idl__gcommon_hh_EXTERNAL_GUARD__
#define hpp_manipulation_idl__gcommon_hh_EXTERNAL_GUARD__
#include <hpp/corbaserver/manipulation/gcommon-idl.hh>
#endif
#ifndef hpp_manipulation_idl__common_hh_EXTERNAL_GUARD__
#define hpp_manipulation_idl__common_hh_EXTERNAL_GUARD__
#include <hpp/common-idl.hh>
#endif
#ifndef hpp_manipulation_idl__constraints_hh_EXTERNAL_GUARD__
#define hpp_manipulation_idl__constraints_hh_EXTERNAL_GUARD__
#include <hpp/constraints_idl/constraints-idl.hh>
#endif
#ifndef hpp_manipulation_idl__paths_hh_EXTERNAL_GUARD__
#define hpp_manipulation_idl__paths_hh_EXTERNAL_GUARD__
#include <hpp/core_idl/paths-idl.hh>
#endif
#ifndef hpp_manipulation_idl____constraints_hh_EXTERNAL_GUARD__
#define hpp_manipulation_idl____constraints_hh_EXTERNAL_GUARD__
#include <hpp/core_idl/_constraints-idl.hh>
#endif
#ifndef hpp_manipulation_idl__steering__methods_hh_EXTERNAL_GUARD__
#define hpp_manipulation_idl__steering__methods_hh_EXTERNAL_GUARD__
#include <hpp/core_idl/steering_methods-idl.hh>
#endif
#ifndef hpp_manipulation_idl__path__validations_hh_EXTERNAL_GUARD__
#define hpp_manipulation_idl__path__validations_hh_EXTERNAL_GUARD__
#include <hpp/core_idl/path_validations-idl.hh>
#endif



#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE hpp

_CORBA_MODULE_BEG

  _CORBA_MODULE constraints_idl

  _CORBA_MODULE_BEG

#ifndef __hpp_mconstraints__idl_mImplicit__
#define __hpp_mconstraints__idl_mImplicit__

    class Implicit;
    class _objref_Implicit;
    class _impl_Implicit;
    
    typedef _objref_Implicit* Implicit_ptr;
    typedef Implicit_ptr ImplicitRef;

    class Implicit_Helper {
    public:
      typedef Implicit_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_Implicit, Implicit_Helper> Implicit_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_Implicit,Implicit_Helper > Implicit_out;

#endif

    class Implicits_var;

    class Implicits : public _CORBA_Unbounded_Sequence_ObjRef< _objref_Implicit, _CORBA_ObjRef_Element< _objref_Implicit, Implicit_Helper> , Implicit_Helper >  {
    public:
      typedef Implicits_var _var_type;
      inline Implicits() {}
      inline Implicits(const Implicits& _s)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_Implicit, _CORBA_ObjRef_Element< _objref_Implicit, Implicit_Helper> , Implicit_Helper > (_s) {}

      inline Implicits(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_Implicit, _CORBA_ObjRef_Element< _objref_Implicit, Implicit_Helper> , Implicit_Helper > (_max) {}
      inline Implicits(_CORBA_ULong _max, _CORBA_ULong _len, Implicit_ptr* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_Implicit, _CORBA_ObjRef_Element< _objref_Implicit, Implicit_Helper> , Implicit_Helper > (_max, _len, _val, _rel) {}

    

      inline Implicits& operator = (const Implicits& _s) {
        _CORBA_Unbounded_Sequence_ObjRef< _objref_Implicit, _CORBA_ObjRef_Element< _objref_Implicit, Implicit_Helper> , Implicit_Helper > ::operator=(_s);
        return *this;
      }
    };

    class Implicits_out;

    class Implicits_var {
    public:
      inline Implicits_var() : _pd_seq(0) {}
      inline Implicits_var(Implicits* _s) : _pd_seq(_s) {}
      inline Implicits_var(const Implicits_var& _s) {
        if( _s._pd_seq )  _pd_seq = new Implicits(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~Implicits_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline Implicits_var& operator = (Implicits* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline Implicits_var& operator = (const Implicits_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new Implicits;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline _CORBA_ObjRef_Element< _objref_Implicit, Implicit_Helper>  operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline Implicits* operator -> () { return _pd_seq; }
      inline const Implicits* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator Implicits& () const { return *_pd_seq; }
#else
      inline operator const Implicits& () const { return *_pd_seq; }
      inline operator Implicits& () { return *_pd_seq; }
#endif
        
      inline const Implicits& in() const { return *_pd_seq; }
      inline Implicits&       inout()    { return *_pd_seq; }
      inline Implicits*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline Implicits* _retn() { Implicits* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class Implicits_out;
      
    private:
      Implicits* _pd_seq;
    };

    class Implicits_out {
    public:
      inline Implicits_out(Implicits*& _s) : _data(_s) { _data = 0; }
      inline Implicits_out(Implicits_var& _s)
        : _data(_s._pd_seq) { _s = (Implicits*) 0; }
      inline Implicits_out(const Implicits_out& _s) : _data(_s._data) {}
      inline Implicits_out& operator = (const Implicits_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline Implicits_out& operator = (Implicits* _s) {
        _data = _s;
        return *this;
      }
      inline operator Implicits*&()  { return _data; }
      inline Implicits*& ptr()       { return _data; }
      inline Implicits* operator->() { return _data; }

      inline _CORBA_ObjRef_Element< _objref_Implicit, Implicit_Helper>  operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      Implicits*& _data;

    private:
      Implicits_out();
      Implicits_out& operator=(const Implicits_var&);
    };

#ifndef __hpp_mconstraints__idl_mLockedJoint__
#define __hpp_mconstraints__idl_mLockedJoint__

    class LockedJoint;
    class _objref_LockedJoint;
    class _impl_LockedJoint;
    
    typedef _objref_LockedJoint* LockedJoint_ptr;
    typedef LockedJoint_ptr LockedJointRef;

    class LockedJoint_Helper {
    public:
      typedef LockedJoint_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_LockedJoint, LockedJoint_Helper> LockedJoint_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_LockedJoint,LockedJoint_Helper > LockedJoint_out;

#endif

    class LockedJoints_var;

    class LockedJoints : public _CORBA_Unbounded_Sequence_ObjRef< _objref_LockedJoint, _CORBA_ObjRef_Element< _objref_LockedJoint, LockedJoint_Helper> , LockedJoint_Helper >  {
    public:
      typedef LockedJoints_var _var_type;
      inline LockedJoints() {}
      inline LockedJoints(const LockedJoints& _s)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_LockedJoint, _CORBA_ObjRef_Element< _objref_LockedJoint, LockedJoint_Helper> , LockedJoint_Helper > (_s) {}

      inline LockedJoints(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_LockedJoint, _CORBA_ObjRef_Element< _objref_LockedJoint, LockedJoint_Helper> , LockedJoint_Helper > (_max) {}
      inline LockedJoints(_CORBA_ULong _max, _CORBA_ULong _len, LockedJoint_ptr* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_LockedJoint, _CORBA_ObjRef_Element< _objref_LockedJoint, LockedJoint_Helper> , LockedJoint_Helper > (_max, _len, _val, _rel) {}

    

      inline LockedJoints& operator = (const LockedJoints& _s) {
        _CORBA_Unbounded_Sequence_ObjRef< _objref_LockedJoint, _CORBA_ObjRef_Element< _objref_LockedJoint, LockedJoint_Helper> , LockedJoint_Helper > ::operator=(_s);
        return *this;
      }
    };

    class LockedJoints_out;

    class LockedJoints_var {
    public:
      inline LockedJoints_var() : _pd_seq(0) {}
      inline LockedJoints_var(LockedJoints* _s) : _pd_seq(_s) {}
      inline LockedJoints_var(const LockedJoints_var& _s) {
        if( _s._pd_seq )  _pd_seq = new LockedJoints(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~LockedJoints_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline LockedJoints_var& operator = (LockedJoints* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline LockedJoints_var& operator = (const LockedJoints_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new LockedJoints;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline _CORBA_ObjRef_Element< _objref_LockedJoint, LockedJoint_Helper>  operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline LockedJoints* operator -> () { return _pd_seq; }
      inline const LockedJoints* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator LockedJoints& () const { return *_pd_seq; }
#else
      inline operator const LockedJoints& () const { return *_pd_seq; }
      inline operator LockedJoints& () { return *_pd_seq; }
#endif
        
      inline const LockedJoints& in() const { return *_pd_seq; }
      inline LockedJoints&       inout()    { return *_pd_seq; }
      inline LockedJoints*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline LockedJoints* _retn() { LockedJoints* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class LockedJoints_out;
      
    private:
      LockedJoints* _pd_seq;
    };

    class LockedJoints_out {
    public:
      inline LockedJoints_out(LockedJoints*& _s) : _data(_s) { _data = 0; }
      inline LockedJoints_out(LockedJoints_var& _s)
        : _data(_s._pd_seq) { _s = (LockedJoints*) 0; }
      inline LockedJoints_out(const LockedJoints_out& _s) : _data(_s._data) {}
      inline LockedJoints_out& operator = (const LockedJoints_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline LockedJoints_out& operator = (LockedJoints* _s) {
        _data = _s;
        return *this;
      }
      inline operator LockedJoints*&()  { return _data; }
      inline LockedJoints*& ptr()       { return _data; }
      inline LockedJoints* operator->() { return _data; }

      inline _CORBA_ObjRef_Element< _objref_LockedJoint, LockedJoint_Helper>  operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      LockedJoints*& _data;

    private:
      LockedJoints_out();
      LockedJoints_out& operator=(const LockedJoints_var&);
    };

  _CORBA_MODULE_END

  _CORBA_MODULE core_idl

  _CORBA_MODULE_BEG

#ifndef __hpp_mcore__idl_mSteeringMethod__
#define __hpp_mcore__idl_mSteeringMethod__

    class SteeringMethod;
    class _objref_SteeringMethod;
    class _impl_SteeringMethod;
    
    typedef _objref_SteeringMethod* SteeringMethod_ptr;
    typedef SteeringMethod_ptr SteeringMethodRef;

    class SteeringMethod_Helper {
    public:
      typedef SteeringMethod_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_SteeringMethod, SteeringMethod_Helper> SteeringMethod_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_SteeringMethod,SteeringMethod_Helper > SteeringMethod_out;

#endif

#ifndef __hpp_mcore__idl_mPathValidation__
#define __hpp_mcore__idl_mPathValidation__

    class PathValidation;
    class _objref_PathValidation;
    class _impl_PathValidation;
    
    typedef _objref_PathValidation* PathValidation_ptr;
    typedef PathValidation_ptr PathValidationRef;

    class PathValidation_Helper {
    public:
      typedef PathValidation_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_PathValidation, PathValidation_Helper> PathValidation_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_PathValidation,PathValidation_Helper > PathValidation_out;

#endif

  _CORBA_MODULE_END

  _CORBA_MODULE manipulation_idl

  _CORBA_MODULE_BEG

    _CORBA_MODULE graph_idl

    _CORBA_MODULE_BEG

      typedef ::CORBA::ULongLong size_t;
      typedef ::CORBA::ULongLong_out size_t_out;

#ifndef __hpp_mmanipulation__idl_mgraph__idl_mState__
#define __hpp_mmanipulation__idl_mgraph__idl_mState__

      class State;
      class _objref_State;
      class _impl_State;
      
      typedef _objref_State* State_ptr;
      typedef State_ptr StateRef;

      class State_Helper {
      public:
        typedef State_ptr _ptr_type;

        static _ptr_type _nil();
        static _CORBA_Boolean is_nil(_ptr_type);
        static void release(_ptr_type);
        static void duplicate(_ptr_type);
        static void marshalObjRef(_ptr_type, cdrStream&);
        static _ptr_type unmarshalObjRef(cdrStream&);
      };

      typedef _CORBA_ObjRef_Var<_objref_State, State_Helper> State_var;
      typedef _CORBA_ObjRef_OUT_arg<_objref_State,State_Helper > State_out;

#endif

      class States_var;

      class States : public _CORBA_Unbounded_Sequence_ObjRef< _objref_State, _CORBA_ObjRef_Element< _objref_State, State_Helper> , State_Helper >  {
      public:
        typedef States_var _var_type;
        inline States() {}
        inline States(const States& _s)
          : _CORBA_Unbounded_Sequence_ObjRef< _objref_State, _CORBA_ObjRef_Element< _objref_State, State_Helper> , State_Helper > (_s) {}

        inline States(_CORBA_ULong _max)
          : _CORBA_Unbounded_Sequence_ObjRef< _objref_State, _CORBA_ObjRef_Element< _objref_State, State_Helper> , State_Helper > (_max) {}
        inline States(_CORBA_ULong _max, _CORBA_ULong _len, State_ptr* _val, _CORBA_Boolean _rel=0)
          : _CORBA_Unbounded_Sequence_ObjRef< _objref_State, _CORBA_ObjRef_Element< _objref_State, State_Helper> , State_Helper > (_max, _len, _val, _rel) {}

      

        inline States& operator = (const States& _s) {
          _CORBA_Unbounded_Sequence_ObjRef< _objref_State, _CORBA_ObjRef_Element< _objref_State, State_Helper> , State_Helper > ::operator=(_s);
          return *this;
        }
      };

      class States_out;

      class States_var {
      public:
        inline States_var() : _pd_seq(0) {}
        inline States_var(States* _s) : _pd_seq(_s) {}
        inline States_var(const States_var& _s) {
          if( _s._pd_seq )  _pd_seq = new States(*_s._pd_seq);
          else              _pd_seq = 0;
        }
        inline ~States_var() { if( _pd_seq )  delete _pd_seq; }
          
        inline States_var& operator = (States* _s) {
          if( _pd_seq )  delete _pd_seq;
          _pd_seq = _s;
          return *this;
        }
        inline States_var& operator = (const States_var& _s) {
          if( _s._pd_seq ) {
            if( !_pd_seq )  _pd_seq = new States;
            *_pd_seq = *_s._pd_seq;
          } else if( _pd_seq ) {
            delete _pd_seq;
            _pd_seq = 0;
          }
          return *this;
        }
        inline _CORBA_ObjRef_Element< _objref_State, State_Helper>  operator [] (_CORBA_ULong _s) {
          return (*_pd_seq)[_s];
        }

      

        inline States* operator -> () { return _pd_seq; }
        inline const States* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
        inline operator States& () const { return *_pd_seq; }
#else
        inline operator const States& () const { return *_pd_seq; }
        inline operator States& () { return *_pd_seq; }
#endif
          
        inline const States& in() const { return *_pd_seq; }
        inline States&       inout()    { return *_pd_seq; }
        inline States*&      out() {
          if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
          return _pd_seq;
        }
        inline States* _retn() { States* tmp = _pd_seq; _pd_seq = 0; return tmp; }
          
        friend class States_out;
        
      private:
        States* _pd_seq;
      };

      class States_out {
      public:
        inline States_out(States*& _s) : _data(_s) { _data = 0; }
        inline States_out(States_var& _s)
          : _data(_s._pd_seq) { _s = (States*) 0; }
        inline States_out(const States_out& _s) : _data(_s._data) {}
        inline States_out& operator = (const States_out& _s) {
          _data = _s._data;
          return *this;
        }
        inline States_out& operator = (States* _s) {
          _data = _s;
          return *this;
        }
        inline operator States*&()  { return _data; }
        inline States*& ptr()       { return _data; }
        inline States* operator->() { return _data; }

        inline _CORBA_ObjRef_Element< _objref_State, State_Helper>  operator [] (_CORBA_ULong _i) {
          return (*_data)[_i];
        }

      

        States*& _data;

      private:
        States_out();
        States_out& operator=(const States_var&);
      };

#ifndef __hpp_mmanipulation__idl_mgraph__idl_mEdge__
#define __hpp_mmanipulation__idl_mgraph__idl_mEdge__

      class Edge;
      class _objref_Edge;
      class _impl_Edge;
      
      typedef _objref_Edge* Edge_ptr;
      typedef Edge_ptr EdgeRef;

      class Edge_Helper {
      public:
        typedef Edge_ptr _ptr_type;

        static _ptr_type _nil();
        static _CORBA_Boolean is_nil(_ptr_type);
        static void release(_ptr_type);
        static void duplicate(_ptr_type);
        static void marshalObjRef(_ptr_type, cdrStream&);
        static _ptr_type unmarshalObjRef(cdrStream&);
      };

      typedef _CORBA_ObjRef_Var<_objref_Edge, Edge_Helper> Edge_var;
      typedef _CORBA_ObjRef_OUT_arg<_objref_Edge,Edge_Helper > Edge_out;

#endif

      class Edges_var;

      class Edges : public _CORBA_Unbounded_Sequence_ObjRef< _objref_Edge, _CORBA_ObjRef_Element< _objref_Edge, Edge_Helper> , Edge_Helper >  {
      public:
        typedef Edges_var _var_type;
        inline Edges() {}
        inline Edges(const Edges& _s)
          : _CORBA_Unbounded_Sequence_ObjRef< _objref_Edge, _CORBA_ObjRef_Element< _objref_Edge, Edge_Helper> , Edge_Helper > (_s) {}

        inline Edges(_CORBA_ULong _max)
          : _CORBA_Unbounded_Sequence_ObjRef< _objref_Edge, _CORBA_ObjRef_Element< _objref_Edge, Edge_Helper> , Edge_Helper > (_max) {}
        inline Edges(_CORBA_ULong _max, _CORBA_ULong _len, Edge_ptr* _val, _CORBA_Boolean _rel=0)
          : _CORBA_Unbounded_Sequence_ObjRef< _objref_Edge, _CORBA_ObjRef_Element< _objref_Edge, Edge_Helper> , Edge_Helper > (_max, _len, _val, _rel) {}

      

        inline Edges& operator = (const Edges& _s) {
          _CORBA_Unbounded_Sequence_ObjRef< _objref_Edge, _CORBA_ObjRef_Element< _objref_Edge, Edge_Helper> , Edge_Helper > ::operator=(_s);
          return *this;
        }
      };

      class Edges_out;

      class Edges_var {
      public:
        inline Edges_var() : _pd_seq(0) {}
        inline Edges_var(Edges* _s) : _pd_seq(_s) {}
        inline Edges_var(const Edges_var& _s) {
          if( _s._pd_seq )  _pd_seq = new Edges(*_s._pd_seq);
          else              _pd_seq = 0;
        }
        inline ~Edges_var() { if( _pd_seq )  delete _pd_seq; }
          
        inline Edges_var& operator = (Edges* _s) {
          if( _pd_seq )  delete _pd_seq;
          _pd_seq = _s;
          return *this;
        }
        inline Edges_var& operator = (const Edges_var& _s) {
          if( _s._pd_seq ) {
            if( !_pd_seq )  _pd_seq = new Edges;
            *_pd_seq = *_s._pd_seq;
          } else if( _pd_seq ) {
            delete _pd_seq;
            _pd_seq = 0;
          }
          return *this;
        }
        inline _CORBA_ObjRef_Element< _objref_Edge, Edge_Helper>  operator [] (_CORBA_ULong _s) {
          return (*_pd_seq)[_s];
        }

      

        inline Edges* operator -> () { return _pd_seq; }
        inline const Edges* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
        inline operator Edges& () const { return *_pd_seq; }
#else
        inline operator const Edges& () const { return *_pd_seq; }
        inline operator Edges& () { return *_pd_seq; }
#endif
          
        inline const Edges& in() const { return *_pd_seq; }
        inline Edges&       inout()    { return *_pd_seq; }
        inline Edges*&      out() {
          if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
          return _pd_seq;
        }
        inline Edges* _retn() { Edges* tmp = _pd_seq; _pd_seq = 0; return tmp; }
          
        friend class Edges_out;
        
      private:
        Edges* _pd_seq;
      };

      class Edges_out {
      public:
        inline Edges_out(Edges*& _s) : _data(_s) { _data = 0; }
        inline Edges_out(Edges_var& _s)
          : _data(_s._pd_seq) { _s = (Edges*) 0; }
        inline Edges_out(const Edges_out& _s) : _data(_s._data) {}
        inline Edges_out& operator = (const Edges_out& _s) {
          _data = _s._data;
          return *this;
        }
        inline Edges_out& operator = (Edges* _s) {
          _data = _s;
          return *this;
        }
        inline operator Edges*&()  { return _data; }
        inline Edges*& ptr()       { return _data; }
        inline Edges* operator->() { return _data; }

        inline _CORBA_ObjRef_Element< _objref_Edge, Edge_Helper>  operator [] (_CORBA_ULong _i) {
          return (*_data)[_i];
        }

      

        Edges*& _data;

      private:
        Edges_out();
        Edges_out& operator=(const Edges_var&);
      };

#ifndef __hpp_mmanipulation__idl_mgraph__idl_mGraphComponent__
#define __hpp_mmanipulation__idl_mgraph__idl_mGraphComponent__

      class GraphComponent;
      class _objref_GraphComponent;
      class _impl_GraphComponent;
      
      typedef _objref_GraphComponent* GraphComponent_ptr;
      typedef GraphComponent_ptr GraphComponentRef;

      class GraphComponent_Helper {
      public:
        typedef GraphComponent_ptr _ptr_type;

        static _ptr_type _nil();
        static _CORBA_Boolean is_nil(_ptr_type);
        static void release(_ptr_type);
        static void duplicate(_ptr_type);
        static void marshalObjRef(_ptr_type, cdrStream&);
        static _ptr_type unmarshalObjRef(cdrStream&);
      };

      typedef _CORBA_ObjRef_Var<_objref_GraphComponent, GraphComponent_Helper> GraphComponent_var;
      typedef _CORBA_ObjRef_OUT_arg<_objref_GraphComponent,GraphComponent_Helper > GraphComponent_out;

#endif

      // interface GraphComponent
      class GraphComponent {
      public:
        // Declarations for this interface type.
        typedef GraphComponent_ptr _ptr_type;
        typedef GraphComponent_var _var_type;

        static _ptr_type _duplicate(_ptr_type);
        static _ptr_type _narrow(::CORBA::Object_ptr);
        static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
        
        static _ptr_type _nil();

        static inline void _marshalObjRef(_ptr_type, cdrStream&);

        static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
          omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
          if (o)
            return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
          else
            return _nil();
        }

        static _core_attr const char* _PD_repoId;

        // Other IDL defined within this scope.
        
      };

      class _objref_GraphComponent :
        public virtual ::CORBA::Object,
        public virtual omniObjRef
      {
      public:
        char* name();
        size_t id();
        constraints_idl::Implicits* numericalConstraints();
        constraints_idl::LockedJoints* lockedJoints();

        inline _objref_GraphComponent()  { _PR_setobj(0); }  // nil
        _objref_GraphComponent(omniIOR*, omniIdentity*);

      protected:
        virtual ~_objref_GraphComponent();

        
      private:
        virtual void* _ptrToObjRef(const char*);

        _objref_GraphComponent(const _objref_GraphComponent&);
        _objref_GraphComponent& operator = (const _objref_GraphComponent&);
        // not implemented

        friend class GraphComponent;
      };

      class _pof_GraphComponent : public _OMNI_NS(proxyObjectFactory) {
      public:
        inline _pof_GraphComponent() : _OMNI_NS(proxyObjectFactory)(GraphComponent::_PD_repoId) {}
        virtual ~_pof_GraphComponent();

        virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
        virtual _CORBA_Boolean is_a(const char*) const;
      };

      class _impl_GraphComponent :
        public virtual omniServant
      {
      public:
        virtual ~_impl_GraphComponent();

        virtual char* name() = 0;
        virtual size_t id() = 0;
        virtual constraints_idl::Implicits* numericalConstraints() = 0;
        virtual constraints_idl::LockedJoints* lockedJoints() = 0;
        
      public:  // Really protected, workaround for xlC
        virtual _CORBA_Boolean _dispatch(omniCallHandle&);

      private:
        virtual void* _ptrToInterface(const char*);
        virtual const char* _mostDerivedRepoId();
        
      };


#ifndef __hpp_mmanipulation__idl_mgraph__idl_mStateSelector__
#define __hpp_mmanipulation__idl_mgraph__idl_mStateSelector__

      class StateSelector;
      class _objref_StateSelector;
      class _impl_StateSelector;
      
      typedef _objref_StateSelector* StateSelector_ptr;
      typedef StateSelector_ptr StateSelectorRef;

      class StateSelector_Helper {
      public:
        typedef StateSelector_ptr _ptr_type;

        static _ptr_type _nil();
        static _CORBA_Boolean is_nil(_ptr_type);
        static void release(_ptr_type);
        static void duplicate(_ptr_type);
        static void marshalObjRef(_ptr_type, cdrStream&);
        static _ptr_type unmarshalObjRef(cdrStream&);
      };

      typedef _CORBA_ObjRef_Var<_objref_StateSelector, StateSelector_Helper> StateSelector_var;
      typedef _CORBA_ObjRef_OUT_arg<_objref_StateSelector,StateSelector_Helper > StateSelector_out;

#endif

      // interface StateSelector
      class StateSelector {
      public:
        // Declarations for this interface type.
        typedef StateSelector_ptr _ptr_type;
        typedef StateSelector_var _var_type;

        static _ptr_type _duplicate(_ptr_type);
        static _ptr_type _narrow(::CORBA::Object_ptr);
        static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
        
        static _ptr_type _nil();

        static inline void _marshalObjRef(_ptr_type, cdrStream&);

        static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
          omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
          if (o)
            return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
          else
            return _nil();
        }

        static _core_attr const char* _PD_repoId;

        // Other IDL defined within this scope.
        
      };

      class _objref_StateSelector :
        public virtual _objref_GraphComponent
      {
      public:
        States* getStates();

        inline _objref_StateSelector()  { _PR_setobj(0); }  // nil
        _objref_StateSelector(omniIOR*, omniIdentity*);

      protected:
        virtual ~_objref_StateSelector();

        
      private:
        virtual void* _ptrToObjRef(const char*);

        _objref_StateSelector(const _objref_StateSelector&);
        _objref_StateSelector& operator = (const _objref_StateSelector&);
        // not implemented

        friend class StateSelector;
      };

      class _pof_StateSelector : public _OMNI_NS(proxyObjectFactory) {
      public:
        inline _pof_StateSelector() : _OMNI_NS(proxyObjectFactory)(StateSelector::_PD_repoId) {}
        virtual ~_pof_StateSelector();

        virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
        virtual _CORBA_Boolean is_a(const char*) const;
      };

      class _impl_StateSelector :
        public virtual _impl_GraphComponent
      {
      public:
        virtual ~_impl_StateSelector();

        virtual States* getStates() = 0;
        
      public:  // Really protected, workaround for xlC
        virtual _CORBA_Boolean _dispatch(omniCallHandle&);

      private:
        virtual void* _ptrToInterface(const char*);
        virtual const char* _mostDerivedRepoId();
        
      };


#ifndef __hpp_mmanipulation__idl_mgraph__idl_mGraph__
#define __hpp_mmanipulation__idl_mgraph__idl_mGraph__

      class Graph;
      class _objref_Graph;
      class _impl_Graph;
      
      typedef _objref_Graph* Graph_ptr;
      typedef Graph_ptr GraphRef;

      class Graph_Helper {
      public:
        typedef Graph_ptr _ptr_type;

        static _ptr_type _nil();
        static _CORBA_Boolean is_nil(_ptr_type);
        static void release(_ptr_type);
        static void duplicate(_ptr_type);
        static void marshalObjRef(_ptr_type, cdrStream&);
        static _ptr_type unmarshalObjRef(cdrStream&);
      };

      typedef _CORBA_ObjRef_Var<_objref_Graph, Graph_Helper> Graph_var;
      typedef _CORBA_ObjRef_OUT_arg<_objref_Graph,Graph_Helper > Graph_out;

#endif

      // interface Graph
      class Graph {
      public:
        // Declarations for this interface type.
        typedef Graph_ptr _ptr_type;
        typedef Graph_var _var_type;

        static _ptr_type _duplicate(_ptr_type);
        static _ptr_type _narrow(::CORBA::Object_ptr);
        static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
        
        static _ptr_type _nil();

        static inline void _marshalObjRef(_ptr_type, cdrStream&);

        static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
          omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
          if (o)
            return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
          else
            return _nil();
        }

        static _core_attr const char* _PD_repoId;

        // Other IDL defined within this scope.
        
      };

      class _objref_Graph :
        public virtual _objref_GraphComponent
      {
      public:
        StateSelector_ptr getStateSelector();
        GraphComponent_ptr get(::hpp::manipulation_idl::graph_idl::size_t id);
        size_t nbComponents();
        void initialize();

        inline _objref_Graph()  { _PR_setobj(0); }  // nil
        _objref_Graph(omniIOR*, omniIdentity*);

      protected:
        virtual ~_objref_Graph();

        
      private:
        virtual void* _ptrToObjRef(const char*);

        _objref_Graph(const _objref_Graph&);
        _objref_Graph& operator = (const _objref_Graph&);
        // not implemented

        friend class Graph;
      };

      class _pof_Graph : public _OMNI_NS(proxyObjectFactory) {
      public:
        inline _pof_Graph() : _OMNI_NS(proxyObjectFactory)(Graph::_PD_repoId) {}
        virtual ~_pof_Graph();

        virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
        virtual _CORBA_Boolean is_a(const char*) const;
      };

      class _impl_Graph :
        public virtual _impl_GraphComponent
      {
      public:
        virtual ~_impl_Graph();

        virtual StateSelector_ptr getStateSelector() = 0;
        virtual GraphComponent_ptr get(::hpp::manipulation_idl::graph_idl::size_t id) = 0;
        virtual size_t nbComponents() = 0;
        virtual void initialize() = 0;
        
      public:  // Really protected, workaround for xlC
        virtual _CORBA_Boolean _dispatch(omniCallHandle&);

      private:
        virtual void* _ptrToInterface(const char*);
        virtual const char* _mostDerivedRepoId();
        
      };


#ifndef __hpp_mmanipulation__idl_mgraph__idl_mState__
#define __hpp_mmanipulation__idl_mgraph__idl_mState__

      class State;
      class _objref_State;
      class _impl_State;
      
      typedef _objref_State* State_ptr;
      typedef State_ptr StateRef;

      class State_Helper {
      public:
        typedef State_ptr _ptr_type;

        static _ptr_type _nil();
        static _CORBA_Boolean is_nil(_ptr_type);
        static void release(_ptr_type);
        static void duplicate(_ptr_type);
        static void marshalObjRef(_ptr_type, cdrStream&);
        static _ptr_type unmarshalObjRef(cdrStream&);
      };

      typedef _CORBA_ObjRef_Var<_objref_State, State_Helper> State_var;
      typedef _CORBA_ObjRef_OUT_arg<_objref_State,State_Helper > State_out;

#endif

      // interface State
      class State {
      public:
        // Declarations for this interface type.
        typedef State_ptr _ptr_type;
        typedef State_var _var_type;

        static _ptr_type _duplicate(_ptr_type);
        static _ptr_type _narrow(::CORBA::Object_ptr);
        static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
        
        static _ptr_type _nil();

        static inline void _marshalObjRef(_ptr_type, cdrStream&);

        static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
          omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
          if (o)
            return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
          else
            return _nil();
        }

        static _core_attr const char* _PD_repoId;

        // Other IDL defined within this scope.
        
      };

      class _objref_State :
        public virtual _objref_GraphComponent
      {
      public:
        Edges* neighborEdges();
        Edges* hiddenNeighbors();

        inline _objref_State()  { _PR_setobj(0); }  // nil
        _objref_State(omniIOR*, omniIdentity*);

      protected:
        virtual ~_objref_State();

        
      private:
        virtual void* _ptrToObjRef(const char*);

        _objref_State(const _objref_State&);
        _objref_State& operator = (const _objref_State&);
        // not implemented

        friend class State;
      };

      class _pof_State : public _OMNI_NS(proxyObjectFactory) {
      public:
        inline _pof_State() : _OMNI_NS(proxyObjectFactory)(State::_PD_repoId) {}
        virtual ~_pof_State();

        virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
        virtual _CORBA_Boolean is_a(const char*) const;
      };

      class _impl_State :
        public virtual _impl_GraphComponent
      {
      public:
        virtual ~_impl_State();

        virtual Edges* neighborEdges() = 0;
        virtual Edges* hiddenNeighbors() = 0;
        
      public:  // Really protected, workaround for xlC
        virtual _CORBA_Boolean _dispatch(omniCallHandle&);

      private:
        virtual void* _ptrToInterface(const char*);
        virtual const char* _mostDerivedRepoId();
        
      };


#ifndef __hpp_mmanipulation__idl_mgraph__idl_mEdge__
#define __hpp_mmanipulation__idl_mgraph__idl_mEdge__

      class Edge;
      class _objref_Edge;
      class _impl_Edge;
      
      typedef _objref_Edge* Edge_ptr;
      typedef Edge_ptr EdgeRef;

      class Edge_Helper {
      public:
        typedef Edge_ptr _ptr_type;

        static _ptr_type _nil();
        static _CORBA_Boolean is_nil(_ptr_type);
        static void release(_ptr_type);
        static void duplicate(_ptr_type);
        static void marshalObjRef(_ptr_type, cdrStream&);
        static _ptr_type unmarshalObjRef(cdrStream&);
      };

      typedef _CORBA_ObjRef_Var<_objref_Edge, Edge_Helper> Edge_var;
      typedef _CORBA_ObjRef_OUT_arg<_objref_Edge,Edge_Helper > Edge_out;

#endif

      // interface Edge
      class Edge {
      public:
        // Declarations for this interface type.
        typedef Edge_ptr _ptr_type;
        typedef Edge_var _var_type;

        static _ptr_type _duplicate(_ptr_type);
        static _ptr_type _narrow(::CORBA::Object_ptr);
        static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
        
        static _ptr_type _nil();

        static inline void _marshalObjRef(_ptr_type, cdrStream&);

        static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
          omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
          if (o)
            return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
          else
            return _nil();
        }

        static _core_attr const char* _PD_repoId;

        // Other IDL defined within this scope.
        
      };

      class _objref_Edge :
        public virtual _objref_GraphComponent
      {
      public:
        State_ptr from();
        State_ptr to();
        State_ptr getState();
        void setState(::hpp::manipulation_idl::graph_idl::State_ptr st);
        core_idl::SteeringMethod_ptr getSteeringMethod();
        core_idl::PathValidation_ptr getPathValidation();

        inline _objref_Edge()  { _PR_setobj(0); }  // nil
        _objref_Edge(omniIOR*, omniIdentity*);

      protected:
        virtual ~_objref_Edge();

        
      private:
        virtual void* _ptrToObjRef(const char*);

        _objref_Edge(const _objref_Edge&);
        _objref_Edge& operator = (const _objref_Edge&);
        // not implemented

        friend class Edge;
      };

      class _pof_Edge : public _OMNI_NS(proxyObjectFactory) {
      public:
        inline _pof_Edge() : _OMNI_NS(proxyObjectFactory)(Edge::_PD_repoId) {}
        virtual ~_pof_Edge();

        virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
        virtual _CORBA_Boolean is_a(const char*) const;
      };

      class _impl_Edge :
        public virtual _impl_GraphComponent
      {
      public:
        virtual ~_impl_Edge();

        virtual State_ptr from() = 0;
        virtual State_ptr to() = 0;
        virtual State_ptr getState() = 0;
        virtual void setState(::hpp::manipulation_idl::graph_idl::State_ptr st) = 0;
        virtual core_idl::SteeringMethod_ptr getSteeringMethod() = 0;
        virtual core_idl::PathValidation_ptr getPathValidation() = 0;
        
      public:  // Really protected, workaround for xlC
        virtual _CORBA_Boolean _dispatch(omniCallHandle&);

      private:
        virtual void* _ptrToInterface(const char*);
        virtual const char* _mostDerivedRepoId();
        
      };


    _CORBA_MODULE_END

  _CORBA_MODULE_END

_CORBA_MODULE_END



_CORBA_MODULE POA_hpp
_CORBA_MODULE_BEG

  _CORBA_MODULE constraints_idl
  _CORBA_MODULE_BEG

  _CORBA_MODULE_END

  _CORBA_MODULE core_idl
  _CORBA_MODULE_BEG

  _CORBA_MODULE_END

  _CORBA_MODULE manipulation_idl
  _CORBA_MODULE_BEG

    _CORBA_MODULE graph_idl
    _CORBA_MODULE_BEG

      class GraphComponent :
        public virtual hpp::manipulation_idl::graph_idl::_impl_GraphComponent,
        public virtual ::PortableServer::ServantBase
      {
      public:
        virtual ~GraphComponent();

        inline ::hpp::manipulation_idl::graph_idl::GraphComponent_ptr _this() {
          return (::hpp::manipulation_idl::graph_idl::GraphComponent_ptr) _do_this(::hpp::manipulation_idl::graph_idl::GraphComponent::_PD_repoId);
        }
      };

      class StateSelector :
        public virtual hpp::manipulation_idl::graph_idl::_impl_StateSelector,
        public virtual GraphComponent
      {
      public:
        virtual ~StateSelector();

        inline ::hpp::manipulation_idl::graph_idl::StateSelector_ptr _this() {
          return (::hpp::manipulation_idl::graph_idl::StateSelector_ptr) _do_this(::hpp::manipulation_idl::graph_idl::StateSelector::_PD_repoId);
        }
      };

      class Graph :
        public virtual hpp::manipulation_idl::graph_idl::_impl_Graph,
        public virtual GraphComponent
      {
      public:
        virtual ~Graph();

        inline ::hpp::manipulation_idl::graph_idl::Graph_ptr _this() {
          return (::hpp::manipulation_idl::graph_idl::Graph_ptr) _do_this(::hpp::manipulation_idl::graph_idl::Graph::_PD_repoId);
        }
      };

      class State :
        public virtual hpp::manipulation_idl::graph_idl::_impl_State,
        public virtual GraphComponent
      {
      public:
        virtual ~State();

        inline ::hpp::manipulation_idl::graph_idl::State_ptr _this() {
          return (::hpp::manipulation_idl::graph_idl::State_ptr) _do_this(::hpp::manipulation_idl::graph_idl::State::_PD_repoId);
        }
      };

      class Edge :
        public virtual hpp::manipulation_idl::graph_idl::_impl_Edge,
        public virtual GraphComponent
      {
      public:
        virtual ~Edge();

        inline ::hpp::manipulation_idl::graph_idl::Edge_ptr _this() {
          return (::hpp::manipulation_idl::graph_idl::Edge_ptr) _do_this(::hpp::manipulation_idl::graph_idl::Edge::_PD_repoId);
        }
      };

    _CORBA_MODULE_END

  _CORBA_MODULE_END

_CORBA_MODULE_END



_CORBA_MODULE OBV_hpp
_CORBA_MODULE_BEG

  _CORBA_MODULE constraints_idl
  _CORBA_MODULE_BEG

  _CORBA_MODULE_END

  _CORBA_MODULE core_idl
  _CORBA_MODULE_BEG

  _CORBA_MODULE_END

  _CORBA_MODULE manipulation_idl
  _CORBA_MODULE_BEG

    _CORBA_MODULE graph_idl
    _CORBA_MODULE_BEG

    _CORBA_MODULE_END

  _CORBA_MODULE_END

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr



inline void
hpp::manipulation_idl::graph_idl::GraphComponent::_marshalObjRef(::hpp::manipulation_idl::graph_idl::GraphComponent_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
hpp::manipulation_idl::graph_idl::StateSelector::_marshalObjRef(::hpp::manipulation_idl::graph_idl::StateSelector_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
hpp::manipulation_idl::graph_idl::Graph::_marshalObjRef(::hpp::manipulation_idl::graph_idl::Graph_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
hpp::manipulation_idl::graph_idl::State::_marshalObjRef(::hpp::manipulation_idl::graph_idl::State_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
hpp::manipulation_idl::graph_idl::Edge::_marshalObjRef(::hpp::manipulation_idl::graph_idl::Edge_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}




#ifdef   USE_stub_in_nt_dll_NOT_DEFINED___graph
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED___graph
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED___graph
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED___graph
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED___graph
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED___graph
#endif

#endif  // ____graph_hh__

