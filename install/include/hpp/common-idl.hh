// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __common_hh__
#define __common_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_common
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_common
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_common
#endif






#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE hpp

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_value_type;

  typedef ::CORBA::Double value_type;
  typedef ::CORBA::Double_out value_type_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_size_type;

  typedef ::CORBA::LongLong size_type;
  typedef ::CORBA::LongLong_out size_type_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Names_t;

  class Names_t_var;

  class Names_t : public _CORBA_Unbounded_Sequence_String {
  public:
    typedef Names_t_var _var_type;
    inline Names_t() {}
    inline Names_t(const Names_t& _s)
      : _CORBA_Unbounded_Sequence_String(_s) {}

    inline Names_t(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_String(_max) {}
    inline Names_t(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}

  

    inline Names_t& operator = (const Names_t& _s) {
      _CORBA_Unbounded_Sequence_String::operator=(_s);
      return *this;
    }
  };

  class Names_t_out;

  class Names_t_var {
  public:
    inline Names_t_var() : _pd_seq(0) {}
    inline Names_t_var(Names_t* _s) : _pd_seq(_s) {}
    inline Names_t_var(const Names_t_var& _s) {
      if( _s._pd_seq )  _pd_seq = new Names_t(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~Names_t_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline Names_t_var& operator = (Names_t* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline Names_t_var& operator = (const Names_t_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new Names_t;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline Names_t* operator -> () { return _pd_seq; }
    inline const Names_t* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator Names_t& () const { return *_pd_seq; }
#else
    inline operator const Names_t& () const { return *_pd_seq; }
    inline operator Names_t& () { return *_pd_seq; }
#endif
      
    inline const Names_t& in() const { return *_pd_seq; }
    inline Names_t&       inout()    { return *_pd_seq; }
    inline Names_t*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline Names_t* _retn() { Names_t* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class Names_t_out;
    
  private:
    Names_t* _pd_seq;
  };

  class Names_t_out {
  public:
    inline Names_t_out(Names_t*& _s) : _data(_s) { _data = 0; }
    inline Names_t_out(Names_t_var& _s)
      : _data(_s._pd_seq) { _s = (Names_t*) 0; }
    inline Names_t_out(const Names_t_out& _s) : _data(_s._data) {}
    inline Names_t_out& operator = (const Names_t_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline Names_t_out& operator = (Names_t* _s) {
      _data = _s;
      return *this;
    }
    inline operator Names_t*&()  { return _data; }
    inline Names_t*& ptr()       { return _data; }
    inline Names_t* operator->() { return _data; }

    inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    Names_t*& _data;

  private:
    Names_t_out();
    Names_t_out& operator=(const Names_t_var&);
  };

  class Error : public ::CORBA::UserException {
  public:
    
    ::CORBA::String_member msg;

  

    inline Error() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    Error(const Error&);
    Error(const char* i_msg);
    Error& operator=(const Error&);
    virtual ~Error();
    virtual void _raise() const;
    static Error* _downcast(::CORBA::Exception*);
    static const Error* _downcast(const ::CORBA::Exception*);
    static inline Error* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    void operator>>=(cdrStream&) const ;
    void operator<<=(cdrStream&) ;

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Error;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_boolSeq;

  class boolSeq_var;

  class boolSeq : public _CORBA_Unbounded_Sequence_Boolean {
  public:
    typedef boolSeq_var _var_type;
    inline boolSeq() {}
    inline boolSeq(const boolSeq& _s)
      : _CORBA_Unbounded_Sequence_Boolean(_s) {}

    inline boolSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_Boolean(_max) {}
    inline boolSeq(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Boolean* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_Boolean(_max, _len, _val, _rel) {}

  

    inline boolSeq& operator = (const boolSeq& _s) {
      _CORBA_Unbounded_Sequence_Boolean::operator=(_s);
      return *this;
    }
  };

  class boolSeq_out;

  class boolSeq_var {
  public:
    inline boolSeq_var() : _pd_seq(0) {}
    inline boolSeq_var(boolSeq* _s) : _pd_seq(_s) {}
    inline boolSeq_var(const boolSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new boolSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~boolSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline boolSeq_var& operator = (boolSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline boolSeq_var& operator = (const boolSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new boolSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Boolean& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline boolSeq* operator -> () { return _pd_seq; }
    inline const boolSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator boolSeq& () const { return *_pd_seq; }
#else
    inline operator const boolSeq& () const { return *_pd_seq; }
    inline operator boolSeq& () { return *_pd_seq; }
#endif
      
    inline const boolSeq& in() const { return *_pd_seq; }
    inline boolSeq&       inout()    { return *_pd_seq; }
    inline boolSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline boolSeq* _retn() { boolSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class boolSeq_out;
    
  private:
    boolSeq* _pd_seq;
  };

  class boolSeq_out {
  public:
    inline boolSeq_out(boolSeq*& _s) : _data(_s) { _data = 0; }
    inline boolSeq_out(boolSeq_var& _s)
      : _data(_s._pd_seq) { _s = (boolSeq*) 0; }
    inline boolSeq_out(const boolSeq_out& _s) : _data(_s._data) {}
    inline boolSeq_out& operator = (const boolSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline boolSeq_out& operator = (boolSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator boolSeq*&()  { return _data; }
    inline boolSeq*& ptr()       { return _data; }
    inline boolSeq* operator->() { return _data; }

    inline ::CORBA::Boolean& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    boolSeq*& _data;

  private:
    boolSeq_out();
    boolSeq_out& operator=(const boolSeq_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_intSeq;

  class intSeq_var;

  class intSeq : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef intSeq_var _var_type;
    inline intSeq() {}
    inline intSeq(const intSeq& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline intSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline intSeq(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline intSeq& operator = (const intSeq& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class intSeq_out;

  class intSeq_var {
  public:
    inline intSeq_var() : _pd_seq(0) {}
    inline intSeq_var(intSeq* _s) : _pd_seq(_s) {}
    inline intSeq_var(const intSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new intSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~intSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline intSeq_var& operator = (intSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline intSeq_var& operator = (const intSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new intSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline intSeq* operator -> () { return _pd_seq; }
    inline const intSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator intSeq& () const { return *_pd_seq; }
#else
    inline operator const intSeq& () const { return *_pd_seq; }
    inline operator intSeq& () { return *_pd_seq; }
#endif
      
    inline const intSeq& in() const { return *_pd_seq; }
    inline intSeq&       inout()    { return *_pd_seq; }
    inline intSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline intSeq* _retn() { intSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class intSeq_out;
    
  private:
    intSeq* _pd_seq;
  };

  class intSeq_out {
  public:
    inline intSeq_out(intSeq*& _s) : _data(_s) { _data = 0; }
    inline intSeq_out(intSeq_var& _s)
      : _data(_s._pd_seq) { _s = (intSeq*) 0; }
    inline intSeq_out(const intSeq_out& _s) : _data(_s._data) {}
    inline intSeq_out& operator = (const intSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline intSeq_out& operator = (intSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator intSeq*&()  { return _data; }
    inline intSeq*& ptr()       { return _data; }
    inline intSeq* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    intSeq*& _data;

  private:
    intSeq_out();
    intSeq_out& operator=(const intSeq_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_intSeqSeq;

  class intSeqSeq_var;

  class intSeqSeq : public _CORBA_Unbounded_Sequence< intSeq >  {
  public:
    typedef intSeqSeq_var _var_type;
    inline intSeqSeq() {}
    inline intSeqSeq(const intSeqSeq& _s)
      : _CORBA_Unbounded_Sequence< intSeq > (_s) {}

    inline intSeqSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< intSeq > (_max) {}
    inline intSeqSeq(_CORBA_ULong _max, _CORBA_ULong _len, intSeq* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< intSeq > (_max, _len, _val, _rel) {}

  

    inline intSeqSeq& operator = (const intSeqSeq& _s) {
      _CORBA_Unbounded_Sequence< intSeq > ::operator=(_s);
      return *this;
    }
  };

  class intSeqSeq_out;

  class intSeqSeq_var {
  public:
    inline intSeqSeq_var() : _pd_seq(0) {}
    inline intSeqSeq_var(intSeqSeq* _s) : _pd_seq(_s) {}
    inline intSeqSeq_var(const intSeqSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new intSeqSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~intSeqSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline intSeqSeq_var& operator = (intSeqSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline intSeqSeq_var& operator = (const intSeqSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new intSeqSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline intSeq& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline intSeqSeq* operator -> () { return _pd_seq; }
    inline const intSeqSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator intSeqSeq& () const { return *_pd_seq; }
#else
    inline operator const intSeqSeq& () const { return *_pd_seq; }
    inline operator intSeqSeq& () { return *_pd_seq; }
#endif
      
    inline const intSeqSeq& in() const { return *_pd_seq; }
    inline intSeqSeq&       inout()    { return *_pd_seq; }
    inline intSeqSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline intSeqSeq* _retn() { intSeqSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class intSeqSeq_out;
    
  private:
    intSeqSeq* _pd_seq;
  };

  class intSeqSeq_out {
  public:
    inline intSeqSeq_out(intSeqSeq*& _s) : _data(_s) { _data = 0; }
    inline intSeqSeq_out(intSeqSeq_var& _s)
      : _data(_s._pd_seq) { _s = (intSeqSeq*) 0; }
    inline intSeqSeq_out(const intSeqSeq_out& _s) : _data(_s._data) {}
    inline intSeqSeq_out& operator = (const intSeqSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline intSeqSeq_out& operator = (intSeqSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator intSeqSeq*&()  { return _data; }
    inline intSeqSeq*& ptr()       { return _data; }
    inline intSeqSeq* operator->() { return _data; }

    inline intSeq& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    intSeqSeq*& _data;

  private:
    intSeqSeq_out();
    intSeqSeq_out& operator=(const intSeqSeq_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_floatSeq;

  class floatSeq_var;

  class floatSeq : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 >  {
  public:
    typedef floatSeq_var _var_type;
    inline floatSeq() {}
    inline floatSeq(const floatSeq& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_s) {}

    inline floatSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max) {}
    inline floatSeq(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Double* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max, _len, _val, _rel) {}

  

    inline floatSeq& operator = (const floatSeq& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > ::operator=(_s);
      return *this;
    }
  };

  class floatSeq_out;

  class floatSeq_var {
  public:
    inline floatSeq_var() : _pd_seq(0) {}
    inline floatSeq_var(floatSeq* _s) : _pd_seq(_s) {}
    inline floatSeq_var(const floatSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new floatSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~floatSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline floatSeq_var& operator = (floatSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline floatSeq_var& operator = (const floatSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new floatSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Double& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline floatSeq* operator -> () { return _pd_seq; }
    inline const floatSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator floatSeq& () const { return *_pd_seq; }
#else
    inline operator const floatSeq& () const { return *_pd_seq; }
    inline operator floatSeq& () { return *_pd_seq; }
#endif
      
    inline const floatSeq& in() const { return *_pd_seq; }
    inline floatSeq&       inout()    { return *_pd_seq; }
    inline floatSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline floatSeq* _retn() { floatSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class floatSeq_out;
    
  private:
    floatSeq* _pd_seq;
  };

  class floatSeq_out {
  public:
    inline floatSeq_out(floatSeq*& _s) : _data(_s) { _data = 0; }
    inline floatSeq_out(floatSeq_var& _s)
      : _data(_s._pd_seq) { _s = (floatSeq*) 0; }
    inline floatSeq_out(const floatSeq_out& _s) : _data(_s._data) {}
    inline floatSeq_out& operator = (const floatSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline floatSeq_out& operator = (floatSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator floatSeq*&()  { return _data; }
    inline floatSeq*& ptr()       { return _data; }
    inline floatSeq* operator->() { return _data; }

    inline ::CORBA::Double& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    floatSeq*& _data;

  private:
    floatSeq_out();
    floatSeq_out& operator=(const floatSeq_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_floatSeqSeq;

  class floatSeqSeq_var;

  class floatSeqSeq : public _CORBA_Unbounded_Sequence< floatSeq >  {
  public:
    typedef floatSeqSeq_var _var_type;
    inline floatSeqSeq() {}
    inline floatSeqSeq(const floatSeqSeq& _s)
      : _CORBA_Unbounded_Sequence< floatSeq > (_s) {}

    inline floatSeqSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< floatSeq > (_max) {}
    inline floatSeqSeq(_CORBA_ULong _max, _CORBA_ULong _len, floatSeq* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< floatSeq > (_max, _len, _val, _rel) {}

  

    inline floatSeqSeq& operator = (const floatSeqSeq& _s) {
      _CORBA_Unbounded_Sequence< floatSeq > ::operator=(_s);
      return *this;
    }
  };

  class floatSeqSeq_out;

  class floatSeqSeq_var {
  public:
    inline floatSeqSeq_var() : _pd_seq(0) {}
    inline floatSeqSeq_var(floatSeqSeq* _s) : _pd_seq(_s) {}
    inline floatSeqSeq_var(const floatSeqSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new floatSeqSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~floatSeqSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline floatSeqSeq_var& operator = (floatSeqSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline floatSeqSeq_var& operator = (const floatSeqSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new floatSeqSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline floatSeq& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline floatSeqSeq* operator -> () { return _pd_seq; }
    inline const floatSeqSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator floatSeqSeq& () const { return *_pd_seq; }
#else
    inline operator const floatSeqSeq& () const { return *_pd_seq; }
    inline operator floatSeqSeq& () { return *_pd_seq; }
#endif
      
    inline const floatSeqSeq& in() const { return *_pd_seq; }
    inline floatSeqSeq&       inout()    { return *_pd_seq; }
    inline floatSeqSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline floatSeqSeq* _retn() { floatSeqSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class floatSeqSeq_out;
    
  private:
    floatSeqSeq* _pd_seq;
  };

  class floatSeqSeq_out {
  public:
    inline floatSeqSeq_out(floatSeqSeq*& _s) : _data(_s) { _data = 0; }
    inline floatSeqSeq_out(floatSeqSeq_var& _s)
      : _data(_s._pd_seq) { _s = (floatSeqSeq*) 0; }
    inline floatSeqSeq_out(const floatSeqSeq_out& _s) : _data(_s._data) {}
    inline floatSeqSeq_out& operator = (const floatSeqSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline floatSeqSeq_out& operator = (floatSeqSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator floatSeqSeq*&()  { return _data; }
    inline floatSeqSeq*& ptr()       { return _data; }
    inline floatSeqSeq* operator->() { return _data; }

    inline floatSeq& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    floatSeqSeq*& _data;

  private:
    floatSeqSeq_out();
    floatSeqSeq_out& operator=(const floatSeqSeq_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Transform_;

  typedef ::CORBA::Double Transform_[7];
  typedef ::CORBA::Double Transform__slice;

  _CORBA_MODULE_INLINE Transform__slice* Transform__alloc() {
    return new Transform__slice[7];
  }

  _CORBA_MODULE_INLINE Transform__slice* Transform__dup(const Transform__slice* _s) {
    if (!_s) return 0;
    Transform__slice* _data = Transform__alloc();
    if (_data) {
      for (_CORBA_ULong _0i0 = 0; _0i0 < 7; _0i0++){
        
        _data[_0i0] = _s[_0i0];

      }
  
    }
    return _data;
  }

  _CORBA_MODULE_INLINE void Transform__copy(Transform__slice* _to, const Transform__slice* _from){
    for (_CORBA_ULong _0i0 = 0; _0i0 < 7; _0i0++){
      
      _to[_0i0] = _from[_0i0];

    }
  
  }

  _CORBA_MODULE_INLINE void Transform__free(Transform__slice* _s) {
    delete [] _s;
  }

  class Transform__copyHelper {
  public:
    static inline Transform__slice* alloc() { return ::hpp::Transform__alloc(); }
    static inline Transform__slice* dup(const Transform__slice* p) { return ::hpp::Transform__dup(p); }
    static inline void free(Transform__slice* p) { ::hpp::Transform__free(p); }
  };

  typedef _CORBA_Array_Fix_Var<Transform__copyHelper,Transform__slice> Transform__var;
  typedef _CORBA_Array_Fix_Forany<Transform__copyHelper,Transform__slice> Transform__forany;

  typedef Transform__slice* Transform__out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TransformSeq;

  class TransformSeq_var;

  class TransformSeq : public _CORBA_Unbounded_Sequence_Array_w_FixSizeElement< Transform_, Transform__slice, ::CORBA::Double, 7, 8, 8 >  {
  public:
    typedef TransformSeq_var _var_type;
    inline TransformSeq() {}
    inline TransformSeq(const TransformSeq& _s)
      : _CORBA_Unbounded_Sequence_Array_w_FixSizeElement< Transform_, Transform__slice, ::CORBA::Double, 7, 8, 8 > (_s) {}

    inline TransformSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_Array_w_FixSizeElement< Transform_, Transform__slice, ::CORBA::Double, 7, 8, 8 > (_max) {}
    inline TransformSeq(_CORBA_ULong _max, _CORBA_ULong _len, Transform_* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_Array_w_FixSizeElement< Transform_, Transform__slice, ::CORBA::Double, 7, 8, 8 > (_max, _len, _val, _rel) {}

  

    inline TransformSeq& operator = (const TransformSeq& _s) {
      _CORBA_Unbounded_Sequence_Array_w_FixSizeElement< Transform_, Transform__slice, ::CORBA::Double, 7, 8, 8 > ::operator=(_s);
      return *this;
    }
  };

  class TransformSeq_out;

  class TransformSeq_var {
  public:
    inline TransformSeq_var() : _pd_seq(0) {}
    inline TransformSeq_var(TransformSeq* _s) : _pd_seq(_s) {}
    inline TransformSeq_var(const TransformSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new TransformSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~TransformSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline TransformSeq_var& operator = (TransformSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline TransformSeq_var& operator = (const TransformSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new TransformSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline Transform__slice* operator [] (_CORBA_ULong _s) {
      return (Transform__slice*) ((_pd_seq->NP_data())[_s]);
    }

  

    inline TransformSeq* operator -> () { return _pd_seq; }
    inline const TransformSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator TransformSeq& () const { return *_pd_seq; }
#else
    inline operator const TransformSeq& () const { return *_pd_seq; }
    inline operator TransformSeq& () { return *_pd_seq; }
#endif
      
    inline const TransformSeq& in() const { return *_pd_seq; }
    inline TransformSeq&       inout()    { return *_pd_seq; }
    inline TransformSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline TransformSeq* _retn() { TransformSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class TransformSeq_out;
    
  private:
    TransformSeq* _pd_seq;
  };

  class TransformSeq_out {
  public:
    inline TransformSeq_out(TransformSeq*& _s) : _data(_s) { _data = 0; }
    inline TransformSeq_out(TransformSeq_var& _s)
      : _data(_s._pd_seq) { _s = (TransformSeq*) 0; }
    inline TransformSeq_out(const TransformSeq_out& _s) : _data(_s._data) {}
    inline TransformSeq_out& operator = (const TransformSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline TransformSeq_out& operator = (TransformSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator TransformSeq*&()  { return _data; }
    inline TransformSeq*& ptr()       { return _data; }
    inline TransformSeq* operator->() { return _data; }

    inline Transform__slice* operator [] (_CORBA_ULong _i) {
      return (Transform__slice*) ((_data->NP_data())[_i]);
    }

  

    TransformSeq*& _data;

  private:
    TransformSeq_out();
    TransformSeq_out& operator=(const TransformSeq_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Quaternion_;

  typedef ::CORBA::Double Quaternion_[4];
  typedef ::CORBA::Double Quaternion__slice;

  _CORBA_MODULE_INLINE Quaternion__slice* Quaternion__alloc() {
    return new Quaternion__slice[4];
  }

  _CORBA_MODULE_INLINE Quaternion__slice* Quaternion__dup(const Quaternion__slice* _s) {
    if (!_s) return 0;
    Quaternion__slice* _data = Quaternion__alloc();
    if (_data) {
      for (_CORBA_ULong _0i0 = 0; _0i0 < 4; _0i0++){
        
        _data[_0i0] = _s[_0i0];

      }
  
    }
    return _data;
  }

  _CORBA_MODULE_INLINE void Quaternion__copy(Quaternion__slice* _to, const Quaternion__slice* _from){
    for (_CORBA_ULong _0i0 = 0; _0i0 < 4; _0i0++){
      
      _to[_0i0] = _from[_0i0];

    }
  
  }

  _CORBA_MODULE_INLINE void Quaternion__free(Quaternion__slice* _s) {
    delete [] _s;
  }

  class Quaternion__copyHelper {
  public:
    static inline Quaternion__slice* alloc() { return ::hpp::Quaternion__alloc(); }
    static inline Quaternion__slice* dup(const Quaternion__slice* p) { return ::hpp::Quaternion__dup(p); }
    static inline void free(Quaternion__slice* p) { ::hpp::Quaternion__free(p); }
  };

  typedef _CORBA_Array_Fix_Var<Quaternion__copyHelper,Quaternion__slice> Quaternion__var;
  typedef _CORBA_Array_Fix_Forany<Quaternion__copyHelper,Quaternion__slice> Quaternion__forany;

  typedef Quaternion__slice* Quaternion__out;

_CORBA_MODULE_END



_CORBA_MODULE POA_hpp
_CORBA_MODULE_BEG

_CORBA_MODULE_END



_CORBA_MODULE OBV_hpp
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

void operator<<=(::CORBA::Any& _a, const hpp::Names_t& _s);
void operator<<=(::CORBA::Any& _a, hpp::Names_t* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, hpp::Names_t*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const hpp::Names_t*& _sp);

void operator<<=(::CORBA::Any& _a, const hpp::Error& _s);
void operator<<=(::CORBA::Any& _a, const hpp::Error* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const hpp::Error*& _sp);

void operator<<=(::CORBA::Any& _a, const hpp::boolSeq& _s);
void operator<<=(::CORBA::Any& _a, hpp::boolSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, hpp::boolSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const hpp::boolSeq*& _sp);

void operator<<=(::CORBA::Any& _a, const hpp::intSeq& _s);
void operator<<=(::CORBA::Any& _a, hpp::intSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, hpp::intSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const hpp::intSeq*& _sp);

void operator<<=(::CORBA::Any& _a, const hpp::intSeqSeq& _s);
void operator<<=(::CORBA::Any& _a, hpp::intSeqSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, hpp::intSeqSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const hpp::intSeqSeq*& _sp);

void operator<<=(::CORBA::Any& _a, const hpp::floatSeq& _s);
void operator<<=(::CORBA::Any& _a, hpp::floatSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, hpp::floatSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const hpp::floatSeq*& _sp);

void operator<<=(::CORBA::Any& _a, const hpp::floatSeqSeq& _s);
void operator<<=(::CORBA::Any& _a, hpp::floatSeqSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, hpp::floatSeqSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const hpp::floatSeqSeq*& _sp);

void operator<<=(::CORBA::Any& _a, const hpp::Transform__forany& _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, hpp::Transform__forany& _s);

void operator<<=(::CORBA::Any& _a, const hpp::TransformSeq& _s);
void operator<<=(::CORBA::Any& _a, hpp::TransformSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, hpp::TransformSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const hpp::TransformSeq*& _sp);

void operator<<=(::CORBA::Any& _a, const hpp::Quaternion__forany& _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, hpp::Quaternion__forany& _s);





#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_common
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_common
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_common
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_common
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_common
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_common
#endif

#endif  // __common_hh__

