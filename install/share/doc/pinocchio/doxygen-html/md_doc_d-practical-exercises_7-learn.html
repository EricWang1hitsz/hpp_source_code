<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>pinocchio: 7) Learning to flight (aka policy learning)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="pinocchio.ico" rel="icon" type="image/x-icon">
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="pinocchio.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">pinocchio
   &#160;<span id="projectnumber">2.1.3</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_doc_d-practical-exercises_7-learn.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">7) Learning to flight (aka policy learning) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Objective</h2>
<p>The objective of this tutorial is to study how to directly solve an optimal control problem, either by computing a trajectory from current state to goal, or by computing a policy. To keep decent computation timings with simple python code, we will only work with a simple inverted pendulum with limited torque, that must swing to raise to standing configuration. The presented algorithms successively compute an optimal trajectory, a discretized policy with a Q-table and with a linear network, and a continuous policy with a deep neural network.</p>
<h2>7.0) prerequesites</h2>
<p>We need a pendulum model and a neural network.</p>
<h3>Prerequesite 1</h3>
<p>Inverted pendulum model</p>
<p>Two models are provided. The first one is continuous and is implemented with Pinocchio and is available in <a href="pendulum_8py_source.html">pendulum.py</a> with class <code>Pendulum</code>. The code is generic for a N-pendulum. We will use the 1-dof model. The state is <code>[q, v]</code> the angle and angular velocity of the pendulum. The control is the joint torque. The pendulum weights 1kg, measures 1m with COM at 0.5m of the joint. Do not forget to start <code>gepetto-gui</code> before rendering the model. Each time the simulator is integrated, it returns a new state and the reward for the previous action (implement to be the weighted sum of squared position, velocity and control). The state is recorded as a member of the class and can be accessed through env.x. Do not forget to copy it before modifying it.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="keyword">from</span> pendulum <span class="keyword">import</span> Pendulum</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="keyword">from</span> pinocchio.utils <span class="keyword">import</span> *</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;env = Pendulum(1)  <span class="comment"># Continuous pendulum</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;NX = env.nobs      <span class="comment"># ... training converges with q,qdot with 2x more neurones.</span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;NU = env.nu        <span class="comment"># Control is dim-1: joint torque</span></div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;x = env.reset()    <span class="comment"># Sample an initial state</span></div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;u = rand(NU)       <span class="comment"># Sample a control</span></div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;x, reward = env.step(u)   <span class="comment"># Integrate simulator for control u and get reward.</span></div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;env.render()       <span class="comment"># Display model at state env.x</span></div></div><!-- fragment --><p>A second version of the same model is provided with a discrete dynamics, in <a href="dpendulum_8py_source.html">dpendulum.py</a>. The state is again <code>[q, v]</code>, however discretized in NQ position and NV velocity. The state is then a integer equal to iq*NV+iv, ranging from 0 to NQ*NV=NX. Controls are also discretized from 0 to NU.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="keyword">from</span> dpendulum <span class="keyword">import</span> DPendulum</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;env = DPendulum()</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;NX = env.nx  <span class="comment"># Number of (discrete) states</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;NU = env.nu  <span class="comment"># Number of (discrete) controls</span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;env.reset()</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;env.step(5)</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;env.render()</div></div><!-- fragment --><p>Other models could be used. In particular, we used a similar API to the Gym from OpenAI, that you might be interested to browsed and possibly try with the following algorithms.</p>
<h3>Prerequesite 2</h3>
<p>A neural network with optimizers</p>
<p>We will use the Tensor Flow from Google, available thanks to pip.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;pip install --user tensorflow tflearn</div></div><!-- fragment --><h2>7.1) Optimizing an optimal trajectory</h2>
<p>For the first tutorial, we implement a nonlinear optimization program optimizing the cost of a single trajectory for the continious pendulum. The trajectory is represented by its initial state x0 and the vector of piecewise-constant control <code>U=[u0 ... uT-1]</code>, with <code>T</code> the number of timestep. The cost is simply the integral of the cost function l(x,u) returned by the pendulum environment.</p>
<p>Then the integral cost is optimized starting from a 0 control trajectory, until the pendulum finally reaches a standing state. Observe that the number of swings is possibly sub-optimal.</p>
<p>The code to optimize the trajectory is available in <a href="ocp_8py_source.html">ocp.py</a>.</p>
<h2>7.2) Q-table resolution for discrete pendulum</h2>
<p>We now consider the discrete model, with NX state and NU control. Imagine this model as a chess board with a maze (possibly nonplanar) drawn on it, and you ask the system to discover a path from an inital state to the final state at the center of the board. When performing a trial, the system is informed of success or failure by receiving reward 1 when reaching the goal, or otherwise 0 after 100 moves. To record the already-explored path, we can stored a table of NX per NU values, each giving how likely we would be rewarded if taking action U at state X. This table is named the Q-table, and corresponds to the Hamiltonian (Q-value) of the discrete system. The Q-values can be back-propagated along the table using the Dijkstra algorithm. Since we do not now the goal(s) states, the back propagation is done along random roll-outs inside the maze, which likely converges to an approximation of the exact Hamiltonian. Once the Q-table is computed, the optimal policy is simply chosen by maximizing the vector of Q-values corresponding to the row of state X.</p>
<p>This algorithm is available in the file <a href="qtable_8py_source.html">qtable.py</a>.</p>
<h2>7.3) Q-table using a linear net</h2>
<p>The idea is to similarly approximate the Q-value for the continuous model. Since the continious model has both infinitely many states and controls, a table can not make it. We will rather use any function basis to approximate the Q-value. For the tutorial, we have chosen to use a deep neural net. Firt, let's use a simple net for storing the Q-table.</p>
<p>Basically, the vectory of Q-values for all possible control u is obtained by multiplying the Q-table by a one-hot vector (0 everywhere except a single 1) corresponding to the state. The optimal policy is then the maximum of this vector: <code>iu^* = argmax(Q*h(ix))</code>, with <code>h(ix) = [ 0 0 ... 0 1 0 ... 0]</code>, ix and iu being indexes of both state and control. We use tensor flow to store array Q. The Q-value net is simply the multiplication of Q by one-hot x, and the policy the argmax of the result.</p>
<p>Now, the coefficients of Q are the parameters defining the Q-value (and then the policy). They must be optimized to fit the cost function. From Hamiltion-Jacobi-Belman equation, we know that Q(x,u) = l(x,u) + max_u2 Q(f(x,u),u2). We optimize the Q value so that this residual is minimized along the samples collected from successive roll-outs inside the maze.</p>
<p>The implementation of this algorithm is available in <a href="qnet_8py_source.html">qnet.py</a>. Observe that the convergence is not as fast as with the Q-Table algorithm.</p>
<h2>7.4) Actor-critic network</h2>
<p>We will now optimize a continuous policy and the corresponding Q-function, using an "Actor-Critic" method proposed in ["Continuous
control with deep reinforcement learning", by Lillicrap et al, arXiv:1509.02971](<a href="https://arxiv.org/abs/1509.02971">https://arxiv.org/abs/1509.02971</a>).</p>
<p>Two networks are used to represent the Q function and the policy. The first network has two inputs: state x and control u. Its outpout is a scalar. It is optimized to minimize the residual corresponding to HJB equation along a batch of sample points collected along previous roll-outs.</p>
<p>The policy function has a single input: state X. Its output is a control vector U (dimension 1 for the pendulum). It is optimize to maximize the Q function , i.e at each state, Pi(x) corresponds to the maximum over all possible controls u of Q(x,u).</p>
<p>Two critical aspects are reported in the paper and implemented in the tutorial. First, we learn over a batch of random samples collected from many previous roll-outs, in order to break the temporal dependancy in the batch. Second, we regularize the optimization of both Q-value (critic) and policy (actor) networks by storing a copy of both network, and only slightly modifying these copy at each steps.</p>
<p>The corresponding algorithm is implemented in the file <a href="continuous_8py_source.html">continuous.py</a> The training phase requires 100 roll-outs and some minutes (maybe more on a virual machine).</p>
<h2>7.5) Training the network with the OCP solver</h2>
<p>Using the OCP solver, you might compute a few optimal trajectories (say 10) starting from various initial conditions. Initialize the replay memory with the 10x50 points composing the 10 optimal trajectories and optimize the network from these replay memory only (without additional roll-outs, but using the same small-size batch). Play with the learning parameters until the network converges.</p>
<p>When properly implemented, the OCP produces better accuracy than the policy. However, at run-time, the policy is much cheaper to evaluate than solving a new OCP. I am currently considering how to use the network to warm-start or guide the OCP solver at run-time.</p>
<p>The provided solvers (trajectory and policy) runs reasonably well for the 1-pendulum. It is more difficult to tune for a more-complex dynamics, such as a 2-pendulum. You may want to try on a quadcopter robot (hence the title of the tutorial) but I except it to be a serious job. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Aug 20 2019 11:12:35 for pinocchio by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
