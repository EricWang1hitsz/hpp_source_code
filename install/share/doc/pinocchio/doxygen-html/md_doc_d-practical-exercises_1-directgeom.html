<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>pinocchio: 1) Move your body (aka direct geometry)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="pinocchio.ico" rel="icon" type="image/x-icon">
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="pinocchio.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">pinocchio
   &#160;<span id="projectnumber">2.1.3</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_doc_d-practical-exercises_1-directgeom.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">1) Move your body (aka direct geometry) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Objective</h2>
<p>In this first series of exercises, we are going to start using the library Pinocchio. We will load in the simulator the model of a simple manipulator arm, the Universal Robot 5, or UR5. This model will be used for a positioning task using simple methods. This set of exercices emphasizes the first part of the class, about direct geometry.</p>
<p>The software Pinocchio is a C++ library provided with a python wrapping that allows us to control it with a python terminal. Let's see how it works.</p>
<h2>1.0) Tips</h2>
<h3>Setup</h3>
<p>For this tutorial, you will need <a href="http://stack-of-tasks.github.io/pinocchio/download.html">Pinocchio</a>, <a href="https://github.com/humanoid-path-planner/gepetto-viewer-corba">Gepetto GUI</a>, and the description of the ur5 robot.</p>
<p>For this, the easiest way is to add <a href="http://robotpkg.openrobots.org/debian.html">robotpkg apt repository</a> and launch: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;sudo apt install robotpkg-py27-pinocchio robotpkg-ur5-description robotpkg-gepetto-viewer-corba robotpkg-osg-dae</div></div><!-- fragment --><h3>Python</h3>
<p>We remind you that you can open a python terminal in your own shell. Simply type : </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;student@student-virtualbox:~$ ipython</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;&gt;&gt;&gt;</div></div><!-- fragment --><p> Afterwards you'll just have to type your commands in this newly opened terminal.</p>
<p>To close the python terminal, just type CTRL-D (CTRL-C first to interrupt any on-going execution).</p>
<p>You can also write you command lines in a file and launch this script without entering the interactive mode (ie. without starting a new python terminal). In your shell, just type: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;student@student-virtualbox:~$ ipython script.py</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;&gt;&gt;&gt;</div></div><!-- fragment --><h3>Pinocchio</h3>
<h4>Basic mathematical objects:</h4>
<p>In the following, we will use numpy <code>Matrix</code> class to represent matrices and vectors. In numpy, vectors simply are matrices with one column. See the following example.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;A = np.matrix([[1, 2, 3, 4], [5, 6, 7, 8]])  <span class="comment"># Define a 2x4 matrix</span></div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;b = np.zeros([4, 1])  <span class="comment"># Define a 4 vector (ie a 4x1 matrix) initialized with 0</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;c = A * b             <span class="comment"># Obtain c by multiplying A by b.</span></div></div><!-- fragment --><p>A bunch of useful functions are packaged in the utils of pinocchio.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="keyword">from</span> pinocchio.utils <span class="keyword">import</span> *</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;eye(6)                      <span class="comment"># Return a 6x6 identity matrix</span></div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;zero(6)                     <span class="comment"># Return a zero 6x1 vector</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;zero([6, 4])                <span class="comment"># Return az zero 6x4</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;matrix rand(6)              <span class="comment"># Random 6x1 vector</span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;isapprox(zero(6), rand(6))  <span class="comment"># Test epsilon equality</span></div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;mprint(rand([6, 6]))        <span class="comment"># Matlab-style print</span></div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;skew(rand(3))               <span class="comment"># Skew &quot;cross-product&quot; 3x3 matrix from a 3x1 vector</span></div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;cross(rand(3), rand(3))     <span class="comment"># Cross product of R^3</span></div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;rotate(<span class="stringliteral">&#39;x&#39;</span>, 0.4)            <span class="comment"># Build a rotation matrix of 0.4rad around X.</span></div></div><!-- fragment --><p>Specific classes are defined to represent objects of \(SE(3)\), \(se(3)\) and \(se(3)^*\). Rigid displacements, elements of \(SE(3)\), are represented by the class <code>SE3</code>.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="keyword">import</span> pinocchio <span class="keyword">as</span> se3</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;R = eye(3); p = zero(3)</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;M0 = se3.SE3(R, p)</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;M = se3.SE3.Random()</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;M.translation = p; M.rotation = R</div></div><!-- fragment --><p>Spatial velocities, elements of \(se(3) = M^6\), are represented by the class <code>Motion</code>.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;v = zero(3); w = zero(3)</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;nu0 = se3.Motion(v, w)</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;nu = se3.Motion.Random()</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;nu.linear = v; nu.angular = w</div></div><!-- fragment --><p>Spatial forces, elements of \(se(3)^* = F^6\), are represented by the class <code>Force</code>.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;f = zero(3); tau = zero(3)</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;phi0 = se3.Force(f, tau)</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;phi = se3.Force.Random()</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;phi.linear = f; phi.angular = tau</div></div><!-- fragment --><h2>1.1) Creating and displaying the robot</h2>
<h3>Robot kinematic tree</h3>
<p>The kinematic tree is represented by two C++ objects called Model (which contains the model constants: lengths, masses, names, etc) and Data (which contains the working memory used by the model algorithms). Both C++ objects are contained in a unique Python class. The first class is called RobotWrapper and is generic.</p>
<p>For the next steps, we are going to work with the RobotWrapper.</p>
<p>Import the class <code>RobotWrapper</code> and create an instance of this class in the python terminal. At initialization, RobotWrapper will read the model description in the URDF file given as argument. In the following, we will use the model of the UR5 robot, available in the directory "models" of pinocchio (available in the homedir of the VBox).</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="keyword">from</span> pinocchio.robot_wrapper <span class="keyword">import</span> RobotWrapper</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="keyword">from</span> os.path <span class="keyword">import</span> join</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;PKG = <span class="stringliteral">&#39;/opt/openrobots/share&#39;</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;URDF = join(PKG, <span class="stringliteral">&#39;ur5_description/urdf/ur5_gripper.urdf&#39;</span>)</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;robot = RobotWrapper(URDF, [PKG])</div></div><!-- fragment --><p>The code of the RobotWrapper class is in <code>/opt/openrobots/lib/python2.7/site-packages/pinocchio/robot_wrapper.py</code>. Do not hesitate to have a look at it and to take inspiration from the implementation of the class functions.</p>
<p>UR5 is a fixed robot with one 6-DOF arms developed by the Danish company Universal Robot. All its 6 joints are revolute joints. Its configuration is in R^6 and is not subject to any constraint. The model of UR5 is described in a URDF file, with the visuals of the bodies of the robot being described as meshed (i.e. polygon soups) using the Collada format ".dae". Both the URDF and the DAE files are available in the package <code>robotpkg-ur5-description</code></p>
<h3>Exploring the model</h3>
<p>The robot model is available in <code>robot.model</code>. It contains the names of all the robot joint <code>names</code>, the kinematic tree <code>parents</code> (i.e. the graph of parents, 0 being the root and having no parents), the position of the current joint in the parent coordinate frame <code>jointPosition</code>, the mass, inertia and center-of-gravity position of all the bodies (condensed in a spatial inertia 6x6 matrix) <code>inertias</code> and the gravity of the associated world <code>gravity</code>. All these functions are documented and are available in the correponding class dictionnary.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="keywordflow">for</span> name, function <span class="keywordflow">in</span> robot.model.__class__.__dict__.items():</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    print(<span class="stringliteral">&quot; \*\*\*\* &quot;</span>, name, <span class="stringliteral">&quot;: &quot;</span>, function.__doc__)</div></div><!-- fragment --><p>Similarly, the robot data are available in <code>robot.data</code>. All the variables allocated by the classical rigid-body dynamics algorithms are stored in <code>robot.data</code> and are available through the python wrapping. Similarly to the model object, the function are documented and are available from the class dictionnary. The most useful in the following will be the placement of the frame associated which each joint output stored in <code>robot.data.oMi</code>.</p>
<p>For example, the robot end effector corresponds to the output of the last joint, called <code>wrist_1_joint</code>. The ID of the joint in the joint list can be recovered from its name, and then used to access its placement:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment"># Get index of end effector</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;idx = robot.index(<span class="stringliteral">&#39;wrist_3_joint&#39;</span>)</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment"># Compute and get the placement of joint number idx</span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;placement = robot.position(q, idx)</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment"># Be carreful, Python always returns references to values.</span></div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment"># You can often .copy() the object to avoid side effects</span></div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment"># Only get the placement</span></div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;placement = robot.data.oMi[idx].copy()</div></div><!-- fragment --><p>Finally, some recurring datas (used in Model and Data) have been wrapped to functions in some python shortcuts, also available in RomeoWrapper:</p>
<ul>
<li>The size of the robot configuration is given by <code>nq</code>.</li>
<li>The dimension of its tangent space (velocity) is <code>nv</code>.</li>
<li>The index of a joint in the tree can be accessed from its name by index (see above).</li>
<li>The classical algorithms are also binded: com, Jcom, mass, biais, joint gravity, position and velocity of each joint.</li>
</ul>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;q = zero(robot.nq)</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;v = rand(robot.nv)</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;robot.com(q)  <span class="comment"># Compute the robot center of mass.</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;robot.position(q, 3)  <span class="comment"># Compute the placement of joint 3</span></div></div><!-- fragment --><h3>Display the robot</h3>
<p>To display the robot, we need an external program called <em>Gepetto Viewer</em>. If you completed the installation in the previous page, you can launch this program, open a new terminal in an empty workspace.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;student@student-virtualbox:~$ gepetto-gui</div></div><!-- fragment --><p>This will start a server waiting for instructions. We will now create a client that will ask the server to perform some requests (such as creating a window or displaying our robot)</p>
<p>In a python terminal you can now load the visual model of the robot in the viewer:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;robot.initDisplay(loadModel=<span class="keyword">True</span>)</div></div><!-- fragment --><p>This will flush the robot model inside the GUI. The argument <code>loadModel=True</code> is mandatory when you start or restart the GUI. In later call to your scripts, you can set the argument to <code>False</code>. A side effector of <code>=True</code> is that it will move the viewpoint inside the GUI to a reference zero position.</p>
<h3>More details about loading the model (optionnal)</h3>
<p>You can access the visual object composing the robot model by <code>robot.visual_model.geometryObject</code>.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;visualObj = robot.visual_model.geometryObjects[4]  <span class="comment"># 3D object representing the robot forarm</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;visualName = visualObj.name                        <span class="comment"># Name associated to this object</span></div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;visualRef = robot.getViewerNodeNames(visualObj)    <span class="comment"># Viewer reference (string) representing this object</span></div></div><!-- fragment --><p>Moving one object</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;q1 = (1, 1, 1, 1, 0, 0, 0)  <span class="comment"># x, y, z, quaternion</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;robot.viewer.gui.applyConfiguration(visualRef, q1)</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;robot.viewer.gui.refresh()  <span class="comment"># Refresh the window.</span></div></div><!-- fragment --><p>Additional objects can be created, like a sphere as follows.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;rgbt = [1.0, 0.2, 0.2, 1.0]  <span class="comment"># red, green, blue, transparency</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;robot.viewer.gui.addSphere(<span class="stringliteral">&quot;world/sphere&quot;</span>, .1, rgbt)  <span class="comment"># .1 is the radius</span></div></div><!-- fragment --><p>The exhaustive list of the object that can be created is available in the IDL of the GUI: <code>/opt/openrobots/share/idl/gepetto/corbaserver/graphical-interface.idl</code></p>
<h2>1.2) Simple pick and place</h2>
<p><em>Objectives:</em> Display the robot at a given configuration or along a given trajectory</p>
<h3>Pick:</h3>
<p>Say we have a target at position <code>[.5, .1, .2]</code> and we would like the robot to grasp it.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;robot.viewer.gui.applyConfiguration(<span class="stringliteral">&quot;world/sphere&quot;</span>, (.5, .1, .2, 1.,0.,0.,0. ))</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;robot.viewer.gui.refresh()  <span class="comment"># Refresh the window.</span></div></div><!-- fragment --><p>First display a small sphere at this position to visualize it.</p>
<p>Then decide by any mean you want a configuration of the robot so that the end effector is touching the sphere.</p>
<p>At the reference position you built, the end effector placement can be obtained by <code>robot.position(q, 6)</code>. Only the translation part of the placement has been selected. The rotation is free.</p>
<p><em>Optional</em> Say now that the object is a rectangle and not a sphere. Pick the object at a reference position with the rotation that is imposed, so that the end effector is aligned with one of the faces of the rectangle.</p>
<h3>Place:</h3>
<p>Choose any trajectory you want in the configuration space, starting from the reference position built in the previous exercice (it can be sinus-cosinus waves, polynomials, splines, straight lines).</p>
<p>Make a for loop to display the robot at sampling positions along this trajectory. The function sleep in module time (from time import sleep) can be used to slow down the loop.</p>
<p>At each instant of your loop, recompute the position of the ball and display it so that it always "sticks" to the robot end effector. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Aug 20 2019 11:12:35 for pinocchio by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
