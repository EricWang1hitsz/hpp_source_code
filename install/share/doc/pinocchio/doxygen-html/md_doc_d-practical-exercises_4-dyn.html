<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>pinocchio: 4) Snap your fingers (aka direct and inverse dynamics)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="pinocchio.ico" rel="icon" type="image/x-icon">
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="pinocchio.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">pinocchio
   &#160;<span id="projectnumber">2.1.3</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_doc_d-practical-exercises_4-dyn.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">4) Snap your fingers (aka direct and inverse dynamics) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Objectives</h2>
<p>The main objective of the tutorial is to implement a simple torque control inside a home-made contact simulator.</p>
<h2>4.0) Technical prerequisites</h2>
<h3>Robots</h3>
<p>We are going to use a 4-finger hand, whose model is defined in Python (no urdf model) using capsule volumes. The code of the robot is <a href="robot__hand_8py_source.html">available here</a>. It needs a <code>Display</code> class wrapping the Gepetto-viewer client <a href="display_8py_source.html">available here</a>, and contains a <code>Robot</code> class implementing the robot hand and a simple example si <a href="hand__example__8py_source.html">available here</a>.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="keyword">from</span> robot_hand <span class="keyword">import</span> Robot</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;robot = Robot()</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;robot.display(robot.q0)</div></div><!-- fragment --><p>Take care that the hand is small: zoom in to see it in the window (or press the space bar).</p>
<h3>Solver</h3>
<p>We will need a proper QP solver with inequality. QuadProg is a Python wrap of a nice Golub-based solver. Install it with PIP</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;pip install --user quadprog</div></div><!-- fragment --><p>QuadProg main function is <code>solve_qp</code>. You have a bit of documentation using the Python help command <code>help(solve_qp)</code>. A simple example follows:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="keyword">from</span> quadprog <span class="keyword">import</span> solve_qp</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment"># Solve min_x .5 xHx - gx s.t. Cx &lt;= d</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;x, _, _, _, _, _ = solve_qp(H, g, C, d)</div></div><!-- fragment --><h2>4.1. Direct dynamics</h2>
<p>Choosing an arbitrary joint torque \(\tau_q\), we now compute the robot acceleration and integrate it.</p>
<p>The dynamic equation of the robot is \(M a_q + b = \tau_q\), with \(M\) the mass, \(a_q\) the joint acceleration and \(b\) the drift. The mass matrix can be computed using <code>CRB</code> algorithm (function of \(q\)). The drift is computed using <code>RNE</code> algorithm (function of \(q\), \(v_q\) and \(a_q\) with \(a_q=0\)).</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="keyword">import</span> pinocchio <span class="keyword">as</span> se3</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;q = rand(robot.model.nq)</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;vq = rand(robot.model.nv)</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;aq0 = zero(robot.model.nv)</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment"># compute dynamic drift -- Coriolis, centrifugal, gravity</span></div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;b = se3.rnea(robot.model, robot.data, q, vq, aq0)</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment"># compute mass matrix M</span></div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;M = se3.crba(robot.model, robot.data, q)</div></div><!-- fragment --><p>These terms correspond to the inverse dynamics. They can be numerically inverted to compute the direct dynamics.</p>
<h4>Question 1</h4>
<p>Using \(M\) and \(b\) computed by the above algorithms, and knowing a given set of joint torques \(\tau_q\), compute \(a_q\) so that \(M*a_q+b = \tau_q\).</p>
<p>Once \(a_q\) as been computed, it is straight forward to integrate it to velocity using \(v_q += a_q * dt\). Integration to joint position is more complex in general. It is implemented in pinocchio:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;q = se3.integrate(robot.model, q, vq * dt)</div></div><!-- fragment --><p>In the particular case of only simple joints (like the robot hand), the same integration \(q += v_q * dt\) also holds.</p>
<h4>Question 2</h4>
<p>Implement the simulation of the robot hand moving freely with constant (possibly 0) torques. Implement a variation where the torques are only joint friction ( \(\tau_q = -K_f v_q\) at each iteration).</p>
<h2>4.2) PD and computed torques</h2>
<p>Now choose a reference joint position (possibly time varying, like in the hand example). The joint torques can then be computed to track the desired position, with \(\tau_q = -K_p (q-q_{des}) - K_v v_q\). Both gains \(K_p\) and \(K_v\) should be properly chosen. Optimal tracking is obtained with \(K_v = 2 \sqrt{K_p}\). In general, a desired velocity is also tracked to avoid tracking errors.</p>
<h4>Question 3</h4>
<p>Implement then simulate a PD, by compute the torques from a PD law, then integrate it using the simulator of question 2.</p>
<p>Here, there is a strong coupling between joints, due to the mass matrix that is not compensated in the simple PD law. In theory, the computed torques is to compute the joint torque by inverse dynamics from a reference joint acceleration. With boils down to canceling the simulation equation by choosing the proper terms in the control law. It is now very interesting to implement in case of perfect dynamics knowledge. It might be more interesting to study in case the simulation is done with the perfect M, while the control is computed with approximate M (for example, using only the diagonal terms of the mass matrix). Let's rather simulate contact.</p>
<h2>4.3) Collision checking</h2>
<p>The robot hand is composed of capsules, i.e. level-set of constant distance to a segment. Collision checking and distances are then easy to implement. The source code of collision checking is available in the <a href="robot__hand_8py_source.html">robot_hand.py</a> file. Pinocchio also implement a complete and efficient collision checking based on FCL, also not used in the tutorial.</p>
<p>Collision checking are done for a set of collision pairs that must be specified to the robot. The collision checking method indeed compute the distance between the two objects, along with the so-called witness points. A method can also be used to display them.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="keyword">from</span> robot_hand <span class="keyword">import</span> Robot</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;robot = Robot()</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;robot.display(robot.q0)</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment"># Create 10 witness points in the rendering window</span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(10):</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    robot.viewer.viewer.gui.addCylinder(<span class="stringliteral">&#39;world/wa%i&#39;</span> % i, .01, .003, [1, 0, 0, 1])</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    robot.viewer.viewer.gui.addCylinder(<span class="stringliteral">&#39;world/wb%i&#39;</span> % i, .01, .003, [1, 0, 0, 1])</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    robot.viewer.viewer.gui.setVisibility(<span class="stringliteral">&#39;world/wa%i&#39;</span> % i, <span class="stringliteral">&#39;OFF&#39;</span>)</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    robot.viewer.viewer.gui.setVisibility(<span class="stringliteral">&#39;world/wb%i&#39;</span> % i, <span class="stringliteral">&#39;OFF&#39;</span>)</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="comment"># Add 4 pairs between finger tips and palm</span></div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;robot.collisionPairs.append([2, 8])</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;robot.collisionPairs.append([2, 11])</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;robot.collisionPairs.append([2, 14])</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;robot.collisionPairs.append([2, 16])</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="comment"># Compute distance between object 2 and 8, i.e the first collision pair</span></div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;idx = 0</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;dist = robot.checkCollision(idx)</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="comment"># Display the collision pair by adding two disks at the witness points.</span></div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;robot.displayCollision(idx, 0)</div></div><!-- fragment --><p>The Jacobian of the corresponding pair can be computed using the <code>collisionJacobian</code> method</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;J = robot.collisionJacobian(idx, q)</div></div><!-- fragment --><p>The jacobian is a 1xN matrix (row matrix) corresponding to the contact normal. Take care that some information are stored in the visual objects when calling checkCollision, that are later used by collisionJacobian. You have to call collisionJacobian right after checkCollision, or the resulting jacobian might not be coherent.</p>
<p>For all collision pairs in contact (distance below 1e-3), the Jacobian must be collected and stacked in a single J matrix (which has as many rows as active constraints). Similarly, distances must be stacked in a vector (same number of rows as the jacobian).</p>
<p>Now, the joint acceleration is constrained by the contact constraint. It can be written as a minimization problem using Gauss principle</p>
<p>\(min \quad \frac{1}{2} (\ddot q - \ddot q_0 )^T M (\ddot q - \ddot q_0 )\)</p>
<p>\(s.t. \quad J \ddot q &gt; 0 \)</p>
<p>where \(\ddot q_0\) is the free acceleration, i.e. the acceleration obtained in Question 2 where no constraint is active.</p>
<p>In theory, the acceleration should be above the "centrifugal" acceleration (i.e. the acceleration caused by joint velocity only, often written \(\dot J \dot q\)) but we neglect it here.</p>
<p>In case of penetration or negative velocity, having only position acceleration is not enough. A "trick" is often to require the contact acceleration to be above a proportional depending of the penetration distance: \(J \ddot q &gt;= -dist\), with \(dist\) the vector of stacked distances.</p>
<h4>Question 4</h4>
<p>Implement a contact simulator using QuadProg, the results of Question 2 and the jacobian matrix of constraints whose distance is below 1e-3.</p>
<p>A better solution to avoid penetration is to implement an impact model. The simplest one is the inelastic impact, where normal velocity is simply canceled at impact. For that, remember inactive contact (i.e. those that were not in collision at previous simulation step). When a collision pair is detected that was not previously active, project the current velocity on the null space of all contacts:</p>
<p>\(\dot q = \dot q - J^+ J \dot q\)</p>
<h4>Question 5</h4>
<p>The complete loop should be as follows: \(\tau_q\) is computed from a PD tracking a time-varying joint position (question 3). After computing \(\tau_q\), all collision pairs must be checked to find those with distances below 1e-3. Corresponding Jacobians must be computed and stacked. If a new collision as appeared, the joint velocity must be projected to nullify it. If not collision is active, the joint acceleration is computed from inverting the mass matrix (question 2). Otherwise, it is computed using QuadProg (question 4). The resulting acceleration is integrated twice (question 1) before displaying the robot starting a new simulation iteration. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Aug 20 2019 11:12:35 for pinocchio by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
